#!/bin/bash
set -e

# Color codes for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Function to print colored output
print_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

print_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

print_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# Show usage
show_usage() {
    cat << EOF
Usage: $0 CONFIG_FILE SQL_FILE

Phase 4: SQL execution script for Redshift Serverless dbt Analytics via Bastion Host

ARGUMENTS:
    CONFIG_FILE     Path to config.json file (required)
    SQL_FILE        Path to SQL file to execute (required)

EXAMPLES:
    # Execute dbt-generated analytics queries
    $0 config.json sql/redshift/verification/verify-zero-etl-all-users.sql

    # Execute analytics schema creation
    $0 config.json sql/redshift/schema/create-analytics-schemas.sql

    # Execute dbt model verification
    $0 config.json sql/redshift/dbt/verify-all-users-view.sql

ENVIRONMENT VARIABLES (optional, overrides auto-detection):
    REDSHIFT_HOST       Redshift Serverless endpoint
    REDSHIFT_PORT       Redshift port (default: 5439)
    REDSHIFT_PASSWORD   Redshift admin password
    REDSHIFT_USER       Redshift admin user
    REDSHIFT_DATABASE   Redshift database name

PREREQUISITES:
    1. bastion-redshift-connection.json must exist (generated by configure-bastion-redshift-sg.py in Phase 3)
    2. psql client must be available
    3. Zero-ETL integration completed (Phase 3)
    4. multitenant_analytics_zeroetl database exists
    5. Script must be executed from workspace directory with connection file

PHASE 4 NOTES:
    This script is optimized for Phase 4 dbt analytics operations, connecting primarily
    to the multitenant_analytics_zeroetl database for analytics queries and model execution.

EOF
}

# Parse arguments
if [[ $# -lt 2 ]] || [[ "$1" == "--help" ]] || [[ "$1" == "-h" ]]; then
    if [[ $# -lt 2 ]]; then
        print_error "Both CONFIG_FILE and SQL_FILE are required"
    fi
    show_usage
    exit 0
fi

CONFIG_FILE="$1"
SQL_FILE="$2"

# Validate SQL file exists
if [[ ! -f "$SQL_FILE" ]]; then
    print_error "SQL file not found: $SQL_FILE"
    exit 1
fi

print_info "=== PHASE 4: REDSHIFT DBT ANALYTICS SQL EXECUTION VIA BASTION ==="
print_info "SQL File: $SQL_FILE"
print_info "Config File: $CONFIG_FILE"

# Function to read config value with jq fallback
read_config_value() {
    local key="$1"
    local default_value="$2"
    local config_file="$3"
    
    if [[ -f "$config_file" ]] && command -v jq >/dev/null 2>&1; then
        local value=$(jq -r "$key // \"$default_value\"" "$config_file" 2>/dev/null)
        # Handle environment variable substitution
        if [[ "$value" =~ ^\$\{(.+)\}$ ]]; then
            local env_var="${BASH_REMATCH[1]}"
            value="${!env_var:-$default_value}"
        fi
        echo "$value"
    else
        echo "$default_value"
    fi
}

# Function to detect phase from SQL file path (Phase 4 specific)
detect_phase_from_sql_file() {
    local sql_file="$1"
    
    # Phase 4 specific path patterns
    if [[ "$sql_file" =~ sql/redshift/dbt/ ]]; then
        echo "dbt"
    elif [[ "$sql_file" =~ sql/redshift/verification/ ]]; then
        echo "verification"
    elif [[ "$sql_file" =~ sql/redshift/schema/ ]]; then
        echo "schema"  
    elif [[ "$sql_file" =~ sql/redshift/([^/]+)/ ]]; then
        local phase="${BASH_REMATCH[1]}"
        echo "$phase"
    else
        # Default phase for Phase 4
        echo "analytics"
    fi
}

# Function to get phase-specific database for Phase 4 Redshift operations
get_phase_database() {
    local phase="$1"
    local config_file="$2"
    local default_db="$3"
    
    # Phase 4 specific database mapping (dbt analytics focused)
    case "$phase" in
        "dbt"|"analytics")
            # Phase 4: Connect to dev database where dbt creates models
            echo "dev"
            ;;
        "verification")
            # Phase 4: Connect to dev database where dbt analytics tables exist
            echo "dev"
            ;;
        "schema")
            # Schema operations may need the Zero-ETL database
            echo "multitenant_analytics_zeroetl"
            ;;
        "database")
            # Database creation phase - connect to default 'dev' database
            echo "dev"
            ;;
        *)
            # Fallback to config file or default, but prefer Zero-ETL database for Phase 4
            if [[ -f "$config_file" ]] && command -v jq >/dev/null 2>&1; then
                local phase_db=$(jq -r ".redshift.phases.\"$phase\".connection_db // \"$default_db\"" "$config_file" 2>/dev/null)
                if [[ "$phase_db" != "null" ]] && [[ -n "$phase_db" ]]; then
                    echo "$phase_db"
                    return 0
                fi
            fi
            # Phase 4 default: Zero-ETL database
            echo "multitenant_analytics_zeroetl"
            ;;
    esac
}

# Function to load Redshift connection from bastion connection file
load_redshift_connection() {
    local connection_file="bastion-redshift-connection.json"
    
    print_info "Loading Redshift connection information for Phase 4..."
    
    # Check if connection file exists
    if [[ ! -f "$connection_file" ]]; then
        print_error "Connection file not found: $connection_file"
        print_error "Please run Phase 3 configure-bastion-redshift-sg.py first to generate connection information"
        exit 1
    fi
    
    # Validate jq is available
    if ! command -v jq >/dev/null 2>&1; then
        print_error "jq is required to parse connection information"
        exit 1
    fi
    
    # Extract connection information
    local host=$(jq -r '.connection.host // empty' "$connection_file" 2>/dev/null)
    local port=$(jq -r '.connection.port // 5439' "$connection_file" 2>/dev/null)
    local user=$(jq -r '.connection.username // "admin"' "$connection_file" 2>/dev/null)
    local password=$(jq -r '.connection.password // empty' "$connection_file" 2>/dev/null)
    local secret_name=$(jq -r '.connection.secret_name // empty' "$connection_file" 2>/dev/null)
    
    # Validate required connection parameters
    if [[ -z "$host" ]] || [[ "$host" == "null" ]]; then
        print_error "Redshift host not found in connection file"
        exit 1
    fi
    
    if [[ -z "$password" ]] || [[ "$password" == "null" ]]; then
        print_warning "Redshift password not found in connection file"
        print_info "Secret name: $secret_name"
    fi
    
    # Set connection variables (allow environment variable override)
    export REDSHIFT_HOST="${REDSHIFT_HOST:-$host}"
    export REDSHIFT_PORT="${REDSHIFT_PORT:-$port}"
    export REDSHIFT_USER="${REDSHIFT_USER:-$user}"
    export REDSHIFT_PASSWORD="${REDSHIFT_PASSWORD:-$password}"
    
    print_success "Phase 4 Redshift connection loaded:"
    print_info "  Host: $REDSHIFT_HOST"
    print_info "  Port: $REDSHIFT_PORT"
    print_info "  User: $REDSHIFT_USER"
    print_info "  Password: ${REDSHIFT_PASSWORD:+***set***}"
    
    return 0
}

# Detect phase from SQL file path
DETECTED_PHASE=$(detect_phase_from_sql_file "$SQL_FILE")
print_info "Detected Phase 4 operation: $DETECTED_PHASE"

# Load Redshift connection information
load_redshift_connection

# Get phase-specific database for Phase 4
if [[ -z "$REDSHIFT_DATABASE" ]]; then
    # Get default database from config
    DEFAULT_DB=$(read_config_value '.redshift.dbName' 'multitenant_analytics_zeroetl' "$CONFIG_FILE")
    # Override with Phase 4 specific database
    REDSHIFT_DB=$(get_phase_database "$DETECTED_PHASE" "$CONFIG_FILE" "$DEFAULT_DB")
    print_info "Using Phase 4 database: $REDSHIFT_DB (operation: $DETECTED_PHASE)"
else
    REDSHIFT_DB="$REDSHIFT_DATABASE"
    print_info "Using environment override database: $REDSHIFT_DB"
fi

print_info "Phase 4 Redshift Connection Configuration:"
print_info "  Host: $REDSHIFT_HOST"  
print_info "  Port: $REDSHIFT_PORT"
print_info "  Database: $REDSHIFT_DB"
print_info "  User: $REDSHIFT_USER"
print_info "  Password: ${REDSHIFT_PASSWORD:+***set***}"

# Validate required connection parameters
if [[ -z "$REDSHIFT_HOST" ]] || [[ "$REDSHIFT_HOST" == "null" ]]; then
    print_error "Redshift host is required. Check bastion-redshift-connection.json"
    exit 1
fi

if [[ -z "$REDSHIFT_PASSWORD" ]] || [[ "$REDSHIFT_PASSWORD" == "null" ]]; then
    print_warning "Redshift password not set. Database connection may fail."
fi

# Check if psql is available
if ! command -v psql >/dev/null 2>&1; then
    print_error "psql command not found. Please install PostgreSQL client."
    exit 1
fi

# Function to execute SQL file
execute_sql_file() {
    local sql_file="$1"
    
    print_info "Executing Phase 4 SQL file: $sql_file"
    print_info "File size: $(wc -c < "$sql_file") bytes"
    
    # Set PGPASSWORD for psql (Redshift is PostgreSQL compatible)
    export PGPASSWORD="$REDSHIFT_PASSWORD"
    
    # Execute SQL file with psql (Redshift uses PostgreSQL wire protocol)
    print_info "Connecting to Redshift Serverless for Phase 4 analytics..."
    print_info "Connection: psql -h $REDSHIFT_HOST -p $REDSHIFT_PORT -U $REDSHIFT_USER -d $REDSHIFT_DB"
    
    # Phase 4 specific execution logic
    case "$DETECTED_PHASE" in
        "dbt"|"analytics")
            print_info "Phase 4 dbt/analytics operation detected - using strict error handling"
            if psql -h "$REDSHIFT_HOST" -p "$REDSHIFT_PORT" -U "$REDSHIFT_USER" -d "$REDSHIFT_DB" -f "$sql_file" -v ON_ERROR_STOP=1 --echo-queries; then
                print_success "Phase 4 dbt/analytics SQL executed successfully"
                return 0
            else
                local exit_code=$?
                print_error "Phase 4 dbt/analytics SQL execution failed with exit code: $exit_code"
                return $exit_code
            fi
            ;;
        "verification")
            print_info "Phase 4 verification operation detected - showing query results"
            if psql -h "$REDSHIFT_HOST" -p "$REDSHIFT_PORT" -U "$REDSHIFT_USER" -d "$REDSHIFT_DB" -f "$sql_file" -v ON_ERROR_STOP=1 --echo-queries; then
                print_success "Phase 4 verification SQL executed successfully"
                return 0
            else
                local exit_code=$?
                print_error "Phase 4 verification SQL execution failed with exit code: $exit_code"
                return $exit_code
            fi
            ;;
        "database")
            print_info "Database creation operation detected - handling gracefully"
            # Use ON_ERROR_STOP=off for database creation to handle "already exists" scenarios
            if psql -h "$REDSHIFT_HOST" -p "$REDSHIFT_PORT" -U "$REDSHIFT_USER" -d "$REDSHIFT_DB" -f "$sql_file" --set ON_ERROR_STOP=off --echo-queries; then
                print_success "Database SQL executed successfully"
                return 0
            else
                local exit_code=$?
                print_warning "Database creation returned exit code: $exit_code"
                print_info "This may indicate the database already exists, which is normal for Phase 4"
                print_success "Database operation completed"
                return 0
            fi
            ;;
        *)
            # Default Phase 4 execution with strict error handling
            if psql -h "$REDSHIFT_HOST" -p "$REDSHIFT_PORT" -U "$REDSHIFT_USER" -d "$REDSHIFT_DB" -f "$sql_file" -v ON_ERROR_STOP=1 --echo-queries; then
                print_success "Phase 4 SQL file executed successfully"
                return 0
            else
                local exit_code=$?
                print_error "Phase 4 SQL file execution failed with exit code: $exit_code"
                return $exit_code
            fi
            ;;
    esac
}

# Function to test Redshift connection for Phase 4
test_redshift_connection() {
    print_info "Testing Phase 4 Redshift connection..."
    
    export PGPASSWORD="$REDSHIFT_PASSWORD"
    
    # Phase 4 specific connection test query (check for Zero-ETL database)
    local test_query="SELECT current_database(), current_user, version(); SELECT COUNT(*) as schema_count FROM information_schema.schemata WHERE schema_name LIKE '%tenant_%' OR schema_name = 'analytics_analytics';"
    
    if echo "$test_query" | psql -h "$REDSHIFT_HOST" -p "$REDSHIFT_PORT" -U "$REDSHIFT_USER" -d "$REDSHIFT_DB" -t; then
        print_success "Phase 4 Redshift connection test successful"
        return 0
    else
        print_error "Phase 4 Redshift connection test failed"
        return 1
    fi
}

# Execute the SQL file
print_info "=== STARTING PHASE 4 REDSHIFT SQL EXECUTION ==="

# Record start time
start_time=$(date +%s)

# Test connection first (Phase 4 specific test)
if ! test_redshift_connection; then
    print_warning "Connection test failed, but continuing with SQL execution..."
fi

# Execute SQL file
if execute_sql_file "$SQL_FILE"; then
    # Calculate execution time
    end_time=$(date +%s)
    duration=$((end_time - start_time))
    
    print_success "=== PHASE 4 REDSHIFT SQL EXECUTION COMPLETED SUCCESSFULLY ==="
    print_info "Execution time: ${duration}s"
    print_info "SQL File: $SQL_FILE"
    print_info "Database: $REDSHIFT_DB"
    print_info "Phase 4 Operation: $DETECTED_PHASE"
    exit 0
else
    # Calculate execution time
    end_time=$(date +%s)
    duration=$((end_time - start_time))
    
    print_error "=== PHASE 4 REDSHIFT SQL EXECUTION FAILED ==="
    print_info "Execution time: ${duration}s"
    print_info "SQL File: $SQL_FILE"
    print_info "Database: $REDSHIFT_DB"
    print_info "Phase 4 Operation: $DETECTED_PHASE"
    exit 1
fi
