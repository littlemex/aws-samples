#!/bin/bash
set -e

# Color codes for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Function to print colored output
print_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

print_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

print_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# Show usage
show_usage() {
    cat << EOF
Usage: $0 CONFIG_FILE SQL_FILE

Generic SQL execution script for Redshift Serverless via Bastion Host

ARGUMENTS:
    CONFIG_FILE     Path to config.json file (required)
    SQL_FILE        Path to SQL file to execute (required)

EXAMPLES:
    # Execute Zero-ETL database creation
    $0 config.json sql/redshift/database/create-integration-database.sql

    # Execute schema creation
    $0 config.json sql/redshift/schema/create-analytics-schemas.sql

    # Execute data verification
    $0 config.json sql/redshift/verification/verify-zero-etl-setup.sql

ENVIRONMENT VARIABLES (optional, overrides auto-detection):
    REDSHIFT_HOST       Redshift Serverless endpoint
    REDSHIFT_PORT       Redshift port (default: 5439)
    REDSHIFT_PASSWORD   Redshift admin password
    REDSHIFT_USER       Redshift admin user
    REDSHIFT_DATABASE   Redshift database name

PREREQUISITES:
    1. bastion-redshift-connection.json must exist (generated by configure-bastion-redshift-sg.py)
    2. psql client must be available
    3. Script must be executed from workspace directory with connection file

EOF
}

# Parse arguments
if [[ $# -lt 2 ]] || [[ "$1" == "--help" ]] || [[ "$1" == "-h" ]]; then
    if [[ $# -lt 2 ]]; then
        print_error "Both CONFIG_FILE and SQL_FILE are required"
    fi
    show_usage
    exit 0
fi

CONFIG_FILE="$1"
SQL_FILE="$2"

# Validate SQL file exists
if [[ ! -f "$SQL_FILE" ]]; then
    print_error "SQL file not found: $SQL_FILE"
    exit 1
fi

print_info "=== REDSHIFT SQL EXECUTION VIA BASTION ==="
print_info "SQL File: $SQL_FILE"
print_info "Config File: $CONFIG_FILE"

# Function to read config value with jq fallback
read_config_value() {
    local key="$1"
    local default_value="$2"
    local config_file="$3"
    
    if [[ -f "$config_file" ]] && command -v jq >/dev/null 2>&1; then
        local value=$(jq -r "$key // \"$default_value\"" "$config_file" 2>/dev/null)
        # Handle environment variable substitution
        if [[ "$value" =~ ^\$\{(.+)\}$ ]]; then
            local env_var="${BASH_REMATCH[1]}"
            value="${!env_var:-$default_value}"
        fi
        echo "$value"
    else
        echo "$default_value"
    fi
}

# Function to detect phase from SQL file path
detect_phase_from_sql_file() {
    local sql_file="$1"
    
    # Extract phase from path pattern: sql/redshift/{phase}/
    if [[ "$sql_file" =~ sql/redshift/([^/]+)/ ]]; then
        local phase="${BASH_REMATCH[1]}"
        echo "$phase"
    else
        # Default phase if pattern doesn't match
        echo "database"  # Default to database phase for Redshift
    fi
}

# Function to get phase-specific database for Redshift
get_phase_database() {
    local phase="$1"
    local config_file="$2"
    local default_db="$3"
    
    # Redshift phase-specific database mapping
    case "$phase" in
        "database")
            # Database creation phase - connect to default 'dev' database
            echo "dev"
            ;;
        "schema"|"data"|"verification")
            # Connect to Zero-ETL integrated database
            echo "multitenant_analytics_zeroetl"
            ;;
        *)
            # Fallback to config file or default
            if [[ -f "$config_file" ]] && command -v jq >/dev/null 2>&1; then
                local phase_db=$(jq -r ".redshift.phases.\"$phase\".connection_db // \"$default_db\"" "$config_file" 2>/dev/null)
                if [[ "$phase_db" != "null" ]] && [[ -n "$phase_db" ]]; then
                    echo "$phase_db"
                    return 0
                fi
            fi
            echo "$default_db"
            ;;
    esac
}

# Function to load Redshift connection from bastion connection file
load_redshift_connection() {
    local connection_file="bastion-redshift-connection.json"
    
    print_info "Loading Redshift connection information..."
    
    # Check if connection file exists
    if [[ ! -f "$connection_file" ]]; then
        print_error "Connection file not found: $connection_file"
        print_error "Please run configure-bastion-redshift-sg.py first to generate connection information"
        exit 1
    fi
    
    # Validate jq is available
    if ! command -v jq >/dev/null 2>&1; then
        print_error "jq is required to parse connection information"
        exit 1
    fi
    
    # Extract connection information
    local host=$(jq -r '.connection.host // empty' "$connection_file" 2>/dev/null)
    local port=$(jq -r '.connection.port // 5439' "$connection_file" 2>/dev/null)
    local user=$(jq -r '.connection.username // "admin"' "$connection_file" 2>/dev/null)
    local password=$(jq -r '.connection.password // empty' "$connection_file" 2>/dev/null)
    local secret_name=$(jq -r '.connection.secret_name // empty' "$connection_file" 2>/dev/null)
    
    # Validate required connection parameters
    if [[ -z "$host" ]] || [[ "$host" == "null" ]]; then
        print_error "Redshift host not found in connection file"
        exit 1
    fi
    
    if [[ -z "$password" ]] || [[ "$password" == "null" ]]; then
        print_warning "Redshift password not found in connection file"
        print_info "Secret name: $secret_name"
    fi
    
    # Set connection variables (allow environment variable override)
    export REDSHIFT_HOST="${REDSHIFT_HOST:-$host}"
    export REDSHIFT_PORT="${REDSHIFT_PORT:-$port}"
    export REDSHIFT_USER="${REDSHIFT_USER:-$user}"
    export REDSHIFT_PASSWORD="${REDSHIFT_PASSWORD:-$password}"
    
    print_success "Redshift connection loaded:"
    print_info "  Host: $REDSHIFT_HOST"
    print_info "  Port: $REDSHIFT_PORT"
    print_info "  User: $REDSHIFT_USER"
    print_info "  Password: ${REDSHIFT_PASSWORD:+***set***}"
    
    return 0
}

# Detect phase from SQL file path
DETECTED_PHASE=$(detect_phase_from_sql_file "$SQL_FILE")
print_info "Detected phase: $DETECTED_PHASE"

# Load Redshift connection information
load_redshift_connection

# Get phase-specific database
if [[ -z "$REDSHIFT_DATABASE" ]]; then
    # Get default database from config
    DEFAULT_DB=$(read_config_value '.redshift.dbName' 'dev' "$CONFIG_FILE")
    # Override with phase-specific database
    REDSHIFT_DB=$(get_phase_database "$DETECTED_PHASE" "$CONFIG_FILE" "$DEFAULT_DB")
    print_info "Using phase-specific database: $REDSHIFT_DB (phase: $DETECTED_PHASE)"
else
    REDSHIFT_DB="$REDSHIFT_DATABASE"
    print_info "Using environment override database: $REDSHIFT_DB"
fi

print_info "Redshift Connection Configuration:"
print_info "  Host: $REDSHIFT_HOST"  
print_info "  Port: $REDSHIFT_PORT"
print_info "  Database: $REDSHIFT_DB"
print_info "  User: $REDSHIFT_USER"
print_info "  Password: ${REDSHIFT_PASSWORD:+***set***}"

# Validate required connection parameters
if [[ -z "$REDSHIFT_HOST" ]] || [[ "$REDSHIFT_HOST" == "null" ]]; then
    print_error "Redshift host is required. Check bastion-redshift-connection.json"
    exit 1
fi

if [[ -z "$REDSHIFT_PASSWORD" ]] || [[ "$REDSHIFT_PASSWORD" == "null" ]]; then
    print_warning "Redshift password not set. Database connection may fail."
fi

# Check if psql is available
if ! command -v psql >/dev/null 2>&1; then
    print_error "psql command not found. Please install PostgreSQL client."
    exit 1
fi

# Function to execute SQL file
execute_sql_file() {
    local sql_file="$1"
    
    print_info "Executing SQL file: $sql_file"
    print_info "File size: $(wc -c < "$sql_file") bytes"
    
    # Set PGPASSWORD for psql (Redshift is PostgreSQL compatible)
    export PGPASSWORD="$REDSHIFT_PASSWORD"
    
    # Execute SQL file with psql (Redshift uses PostgreSQL wire protocol)
    print_info "Connecting to Redshift Serverless..."
    print_info "Connection: psql -h $REDSHIFT_HOST -p $REDSHIFT_PORT -U $REDSHIFT_USER -d $REDSHIFT_DB"
    
    # Check if this is a database creation phase and handle gracefully
    if [[ "$DETECTED_PHASE" == "database" ]]; then
        print_info "Database phase detected - handling CREATE DATABASE gracefully"
        # Use ON_ERROR_STOP=off for database creation to handle "already exists" scenarios
        if psql -h "$REDSHIFT_HOST" -p "$REDSHIFT_PORT" -U "$REDSHIFT_USER" -d "$REDSHIFT_DB" -f "$sql_file" --set ON_ERROR_STOP=off --echo-queries; then
            print_success "SQL file executed successfully (database phase)"
            return 0
        else
            local exit_code=$?
            # For database phase, check if it's just an "already established" error
            print_warning "Database creation returned exit code: $exit_code"
            print_info "This may indicate the database already exists, which is normal"
            print_success "Database phase completed (database may already exist)"
            return 0
        fi
    else
        # For other phases, use strict error handling
        if psql -h "$REDSHIFT_HOST" -p "$REDSHIFT_PORT" -U "$REDSHIFT_USER" -d "$REDSHIFT_DB" -f "$sql_file" -v ON_ERROR_STOP=1 --echo-queries; then
            print_success "SQL file executed successfully"
            return 0
        else
            local exit_code=$?
            print_error "SQL file execution failed with exit code: $exit_code"
            return $exit_code
        fi
    fi
}

# Function to test Redshift connection
test_redshift_connection() {
    print_info "Testing Redshift connection..."
    
    export PGPASSWORD="$REDSHIFT_PASSWORD"
    
    # Simple connection test query (Redshift compatible)
    local test_query="SELECT current_database(), current_user, version();"
    
    if echo "$test_query" | psql -h "$REDSHIFT_HOST" -p "$REDSHIFT_PORT" -U "$REDSHIFT_USER" -d "$REDSHIFT_DB" -t; then
        print_success "Redshift connection test successful"
        return 0
    else
        print_error "Redshift connection test failed"
        return 1
    fi
}

# Execute the SQL file
print_info "=== STARTING REDSHIFT SQL EXECUTION ==="

# Record start time
start_time=$(date +%s)

# Test connection first (optional, but helpful for debugging)
if ! test_redshift_connection; then
    print_warning "Connection test failed, but continuing with SQL execution..."
fi

# Execute SQL file
if execute_sql_file "$SQL_FILE"; then
    # Calculate execution time
    end_time=$(date +%s)
    duration=$((end_time - start_time))
    
    print_success "=== REDSHIFT SQL EXECUTION COMPLETED SUCCESSFULLY ==="
    print_info "Execution time: ${duration}s"
    print_info "SQL File: $SQL_FILE"
    print_info "Database: $REDSHIFT_DB"
    print_info "Phase: $DETECTED_PHASE"
    exit 0
else
    # Calculate execution time
    end_time=$(date +%s)
    duration=$((end_time - start_time))
    
    print_error "=== REDSHIFT SQL EXECUTION FAILED ==="
    print_info "Execution time: ${duration}s"
    print_info "SQL File: $SQL_FILE"
    print_info "Database: $REDSHIFT_DB"
    print_info "Phase: $DETECTED_PHASE"
    exit 1
fi
