#!/bin/bash
set -e

# Color codes for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Function to print colored output
print_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

print_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

print_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# Show usage
show_usage() {
    cat << EOF
Usage: $0 CONFIG_FILE SQL_FILE

dbt-style SQL execution script for Redshift Serverless via Bastion Host
Specialized for Phase 4 dbt View creation and verification

ARGUMENTS:
    CONFIG_FILE     Path to config.json file (required)
    SQL_FILE        Path to dbt SQL file to execute (required)

EXAMPLES:
    # Create dbt-style Views
    $0 config.json sql/redshift/dbt/simple-all-users-view.sql

    # Verify created Views
    $0 config.json sql/redshift/dbt/verify-all-users-view.sql

ENVIRONMENT VARIABLES (optional, overrides auto-detection):
    REDSHIFT_HOST       Redshift Serverless endpoint
    REDSHIFT_PORT       Redshift port (default: 5439)
    REDSHIFT_PASSWORD   Redshift admin password
    REDSHIFT_USER       Redshift admin user
    REDSHIFT_DATABASE   Redshift database name (default: multitenant_analytics_zeroetl)

PREREQUISITES:
    1. bastion-redshift-connection.json must exist (generated by configure-bastion-redshift-sg.py)
    2. psql client must be available
    3. Zero-ETL integration database must be created
    4. Script must be executed from workspace directory with connection file

EOF
}

# Parse arguments
if [[ $# -lt 2 ]] || [[ "$1" == "--help" ]] || [[ "$1" == "-h" ]]; then
    if [[ $# -lt 2 ]]; then
        print_error "Both CONFIG_FILE and SQL_FILE are required"
    fi
    show_usage
    exit 0
fi

CONFIG_FILE="$1"
SQL_FILE="$2"

# Validate SQL file exists
if [[ ! -f "$SQL_FILE" ]]; then
    print_error "SQL file not found: $SQL_FILE"
    exit 1
fi

print_info "=== REDSHIFT DBT-STYLE SQL EXECUTION VIA BASTION ==="
print_info "SQL File: $SQL_FILE"
print_info "Config File: $CONFIG_FILE"

# Function to read config value with jq fallback
read_config_value() {
    local key="$1"
    local default_value="$2"
    local config_file="$3"
    
    if [[ -f "$config_file" ]] && command -v jq >/dev/null 2>&1; then
        local value=$(jq -r "$key // \"$default_value\"" "$config_file" 2>/dev/null)
        # Handle environment variable substitution
        if [[ "$value" =~ ^\$\{(.+)\}$ ]]; then
            local env_var="${BASH_REMATCH[1]}"
            value="${!env_var:-$default_value}"
        fi
        echo "$value"
    else
        echo "$default_value"
    fi
}

# Function to detect dbt operation type from SQL file path
detect_dbt_operation() {
    local sql_file="$1"
    
    # Extract operation from path pattern: sql/redshift/dbt/{operation}
    if [[ "$sql_file" =~ sql/redshift/dbt/([^/]+)\.sql$ ]]; then
        local operation="${BASH_REMATCH[1]}"
        echo "$operation"
    else
        # Default operation if pattern doesn't match
        echo "view"  # Default to view operation for dbt
    fi
}

# Function to get dbt operation-specific database
get_dbt_database() {
    local operation="$1"
    local config_file="$2"
    
    # dbt operations now use regular Redshift database with cross-database reference
    case "$operation" in
        "simple-all-users-view"|"verify-all-users-view"|"view"|"verification")
            # Use regular Redshift database (dev) for View creation, with cross-database reference to Zero-ETL
            echo "dev"
            ;;
        *)
            # Fallback to regular Redshift database
            echo "dev"
            ;;
    esac
}

# Function to load Redshift connection from bastion connection file
load_redshift_connection() {
    local connection_file="bastion-redshift-connection.json"
    
    print_info "Loading Redshift connection information..."
    
    # Check if connection file exists
    if [[ ! -f "$connection_file" ]]; then
        print_error "Connection file not found: $connection_file"
        print_error "Please run configure-bastion-redshift-sg.py first to generate connection information"
        exit 1
    fi
    
    # Validate jq is available
    if ! command -v jq >/dev/null 2>&1; then
        print_error "jq is required to parse connection information"
        exit 1
    fi
    
    # Extract connection information
    local host=$(jq -r '.connection.host // empty' "$connection_file" 2>/dev/null)
    local port=$(jq -r '.connection.port // 5439' "$connection_file" 2>/dev/null)
    local user=$(jq -r '.connection.username // "admin"' "$connection_file" 2>/dev/null)
    local password=$(jq -r '.connection.password // empty' "$connection_file" 2>/dev/null)
    local secret_name=$(jq -r '.connection.secret_name // empty' "$connection_file" 2>/dev/null)
    
    # Validate required connection parameters
    if [[ -z "$host" ]] || [[ "$host" == "null" ]]; then
        print_error "Redshift host not found in connection file"
        exit 1
    fi
    
    if [[ -z "$password" ]] || [[ "$password" == "null" ]]; then
        print_warning "Redshift password not found in connection file"
        print_info "Secret name: $secret_name"
    fi
    
    # Set connection variables (allow environment variable override)
    export REDSHIFT_HOST="${REDSHIFT_HOST:-$host}"
    export REDSHIFT_PORT="${REDSHIFT_PORT:-$port}"
    export REDSHIFT_USER="${REDSHIFT_USER:-$user}"
    export REDSHIFT_PASSWORD="${REDSHIFT_PASSWORD:-$password}"
    
    print_success "Redshift connection loaded:"
    print_info "  Host: $REDSHIFT_HOST"
    print_info "  Port: $REDSHIFT_PORT"
    print_info "  User: $REDSHIFT_USER"
    print_info "  Password: ${REDSHIFT_PASSWORD:+***set***}"
    
    return 0
}

# Detect dbt operation from SQL file path
DETECTED_OPERATION=$(detect_dbt_operation "$SQL_FILE")
print_info "Detected dbt operation: $DETECTED_OPERATION"

# Load Redshift connection information
load_redshift_connection

# Get dbt operation-specific database
if [[ -z "$REDSHIFT_DATABASE" ]]; then
    REDSHIFT_DB=$(get_dbt_database "$DETECTED_OPERATION" "$CONFIG_FILE")
    print_info "Using dbt database: $REDSHIFT_DB (operation: $DETECTED_OPERATION)"
else
    REDSHIFT_DB="$REDSHIFT_DATABASE"
    print_info "Using environment override database: $REDSHIFT_DB"
fi

print_info "Redshift Connection Configuration:"
print_info "  Host: $REDSHIFT_HOST"  
print_info "  Port: $REDSHIFT_PORT"
print_info "  Database: $REDSHIFT_DB"
print_info "  User: $REDSHIFT_USER"
print_info "  Password: ${REDSHIFT_PASSWORD:+***set***}"

# Validate required connection parameters
if [[ -z "$REDSHIFT_HOST" ]] || [[ "$REDSHIFT_HOST" == "null" ]]; then
    print_error "Redshift host is required. Check bastion-redshift-connection.json"
    exit 1
fi

if [[ -z "$REDSHIFT_PASSWORD" ]] || [[ "$REDSHIFT_PASSWORD" == "null" ]]; then
    print_warning "Redshift password not set. Database connection may fail."
fi

# Check if psql is available
if ! command -v psql >/dev/null 2>&1; then
    print_error "psql command not found. Please install PostgreSQL client."
    exit 1
fi

# Function to execute dbt SQL file
execute_dbt_sql_file() {
    local sql_file="$1"
    
    print_info "Executing dbt SQL file: $sql_file"
    print_info "File size: $(wc -c < "$sql_file") bytes"
    
    # Set PGPASSWORD for psql (Redshift is PostgreSQL compatible)
    export PGPASSWORD="$REDSHIFT_PASSWORD"
    
    # Execute SQL file with psql (Redshift uses PostgreSQL wire protocol)
    print_info "Connecting to Redshift Serverless..."
    print_info "Connection: psql -h $REDSHIFT_HOST -p $REDSHIFT_PORT -U $REDSHIFT_USER -d $REDSHIFT_DB"
    
    # For dbt operations, use appropriate error handling
    if [[ "$DETECTED_OPERATION" == *"view"* ]]; then
        print_info "View operation detected - using CREATE OR REPLACE friendly mode"
        # Use ON_ERROR_STOP=on but don't fail on "already exists" scenarios for views
        if psql -h "$REDSHIFT_HOST" -p "$REDSHIFT_PORT" -U "$REDSHIFT_USER" -d "$REDSHIFT_DB" -f "$sql_file" -v ON_ERROR_STOP=1 --echo-queries; then
            print_success "dbt SQL file executed successfully (view operation)"
            return 0
        else
            local exit_code=$?
            print_error "dbt SQL file execution failed with exit code: $exit_code"
            return $exit_code
        fi
    else
        # For verification and other operations, use strict error handling
        if psql -h "$REDSHIFT_HOST" -p "$REDSHIFT_PORT" -U "$REDSHIFT_USER" -d "$REDSHIFT_DB" -f "$sql_file" -v ON_ERROR_STOP=1 --echo-queries; then
            print_success "dbt SQL file executed successfully"
            return 0
        else
            local exit_code=$?
            print_error "dbt SQL file execution failed with exit code: $exit_code"
            return $exit_code
        fi
    fi
}

# Function to test Redshift connection for Zero-ETL database
test_redshift_dbt_xconnection() {
    print_info "Testing Redshift connection to Zero-ETL database..."
    
    export PGPASSWORD="$REDSHIFT_PASSWORD"
    
    # Zero-ETL database specific test query
    local test_query="SELECT current_database(), current_user, 'Zero-ETL DB Connection Test' as message;"
    
    if echo "$test_query" | psql -h "$REDSHIFT_HOST" -p "$REDSHIFT_PORT" -U "$REDSHIFT_USER" -d "$REDSHIFT_DB" -t; then
        print_success "Redshift Zero-ETL database connection test successful"
        
        # Also test if tenant tables exist
        print_info "Checking if tenant tables exist in Zero-ETL database..."
        local tenant_check_query="SELECT schemaname, tablename FROM pg_tables WHERE schemaname LIKE 'tenant_%' LIMIT 3;"
        
        if echo "$tenant_check_query" | psql -h "$REDSHIFT_HOST" -p "$REDSHIFT_PORT" -U "$REDSHIFT_USER" -d "$REDSHIFT_DB" -t; then
            print_success "Tenant tables found in Zero-ETL database"
        else
            print_warning "Tenant tables not found or not accessible in Zero-ETL database"
        fi
        
        return 0
    else
        print_error "Redshift Zero-ETL database connection test failed"
        return 1
    fi
}

# Execute the dbt SQL file
print_info "=== STARTING REDSHIFT DBT SQL EXECUTION ==="

# Record start time
start_time=$(date +%s)

# Test connection first (helpful for debugging Zero-ETL setup)
if ! test_redshift_dbt_xconnection; then
    print_warning "Connection test failed, but continuing with dbt SQL execution..."
fi

# Execute dbt SQL file
if execute_dbt_sql_file "$SQL_FILE"; then
    # Calculate execution time
    end_time=$(date +%s)
    duration=$((end_time - start_time))
    
    print_success "=== REDSHIFT DBT SQL EXECUTION COMPLETED SUCCESSFULLY ==="
    print_info "Execution time: ${duration}s"
    print_info "SQL File: $SQL_FILE"
    print_info "Database: $REDSHIFT_DB"
    print_info "Operation: $DETECTED_OPERATION"
    exit 0
else
    # Calculate execution time
    end_time=$(date +%s)
    duration=$((end_time - start_time))
    
    print_error "=== REDSHIFT DBT SQL EXECUTION FAILED ==="
    print_info "Execution time: ${duration}s"
    print_info "SQL File: $SQL_FILE"
    print_info "Database: $REDSHIFT_DB"
    print_info "Operation: $DETECTED_OPERATION"
    exit 1
fi
