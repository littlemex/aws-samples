# Amazon DocumentDB パフォーマンス・トラブルシューティング・ガイド

Amazon DocumentDB (MongoDB互換) は、ログ分析、リアルタイムアプリケーションモニタリング、クリックストリーム分析などのユースケースに使用されるフルマネージド型のドキュメントデータベースサービスです。
Amazon DocumentDB は MongoDB と互換性のあるドキュメントデータベースです。クラスタの構成やインデックス設定がワークロードに適していないことでパフォーマンスの問題が生じることがあります。
本記事では、パフォーマンストラブルが起きた際に確認すべきポイントを解説します。

## はじめに

Amazon DocumentDB (MongoDB互換) は、OSS である MongoDB と互換性のあるクラスタを簡単に構築し、ドキュメントデータベースとして様々なユースケースで用いられるサービスです。
Amazon DocumentDB は JSON データを簡単に保存、クエリ、インデックス化できるドキュメントデータベースです。
Amazon DocumentDB ではクラスタの設定としてノード数やノードのタイプ、インデックスの設定などを設定してワークロードごとに適した構成を柔軟に作ることが可能です。

柔軟な一方でそれらの設定が実ワークロードに適していない場合、レイテンシー増加、スロットリングエラーなどのトラブルが発生します。
[ベストプラクティス](https://docs.aws.amazon.com/documentdb/latest/developerguide/best_practices.html)は公開されていますが、
それに則って構築を行っても現実的にはガイドで多様なユースケースを考慮し切ることはできません。

トラブルに対する調査方法と短期、中長期での対応策の参考情報を整理することを本資料の目的とします。  
本記事でのトラブルシュート全体の流れとしては以下のようになります。

1. 調査に必要なメトリクスや設定情報を取得する。
2. 調査に対して情報が不足する場合はメトリクスや追加の設定を行う。
3. 収集された情報からトラブルの根本原因の仮説とそれに対する対策を立てる。
4. 対策を実施して問題が解消されるかを観察する。

## 状況判断のために事前に把握すべき情報

Amazon DocumentDB のパフォーマンストラブルシューティングを効果的に行うためには、以下の情報を事前に把握しておくことが重要です。
これらの情報は、問題の原因特定や対策の選択に大きく影響します。

| 確認項目 | 選択肢 | トラブルシューティングへの影響 |
|---------|-------|---------------------------|
| **クラスタータイプ** | Instance-based Cluster | インスタンスベースのクラスター。インスタンスレベルでのメトリクス確認が重要。Performance Insights が利用可能。 |
|  | Elastic Cluster | シャードベースのクラスター。シャード間の負荷分散が重要。クエリプランの確認方法が異なる。 |
| **ストレージ構成** | Standard Storage | 標準的なストレージタイプ。I/O コストが全体の 25% 未満の場合に適している。 |
|  | I/O-Optimized Storage | I/O 負荷が高い場合に適している。I/O コストが全体の25%以上の場合はこちらの方が費用対効果が高い。 |
| **デプロイメントタイプ** | Single-AZ | 単一のアベイラビリティゾーン。開発環境や非クリティカルなワークロードに適している。 |
|  | Multi-AZ | 複数のアベイラビリティゾーン。高可用性が必要な本番環境に適している。 |
| **インスタンスタイプ** | T3/T4g (バースト可能) | 低コストだが、CPU 使用率が高い場合にクレジットが枯渇する可能性がある。開発/テスト環境向け。`CPUCreditBalance` の監視が重要。 |
|  | R5 (メモリ最適化) | 安定したパフォーマンスを提供。本番環境に推奨。最大96 vCPU と 768 GiB メモリまでスケール可能。 |
|  | R6g/R6gd (AWS Graviton2) | R5 と比較して最大 30% のパフォーマンス向上。R6gd は NVMe ストレージ搭載。最大 64 vCPU と 512 GiB メモリまでスケール可能。 |
|  | R7g/R7gd (AWS Graviton3) | 最新世代のプロセッサ。R7gd は NVMe ストレージ搭載。最大 64 vCPU と 512 GiB メモリまでスケール可能。 |
| **インスタンスストレージ** | EBS のみ | 標準的なストレージ構成。永続的なデータストレージに使用。 |
|  | [NVMe-backed](https://docs.aws.amazon.com/ja_jp/documentdb/latest/developerguide/db-instance-nvme.html) | 高速な一時ストレージを提供。クエリパフォーマンスを最大 7 倍向上。R6gd、R6id、R7gd、R7id、X2iedn インスタンスで利用可能。 |
| **最適化オプション** | ドキュメント圧縮 | バージョン 5.0 以降で利用可能。2KB 以上のドキュメントを圧縮し、ストレージと I/O コストを削減。 |
|  | TTLインデックス | 自動的にドキュメントを削除するが、I/O 操作が増加する可能性がある。 |
|  | キャッシング戦略 | ElastiCache などを使用して読み取り負荷を軽減。`BufferCacheHitRatio`の監視が重要。 |
| [**ドキュメント圧縮**](https://docs.aws.amazon.com/ja_jp/documentdb/latest/developerguide/doc-compression.html) | 有効 | デフォルト設定（バージョン5.0以降）。ストレージと I/O コストを削減。コレクションレベルで設定可能。 |
|  | 無効 | 圧縮オーバーヘッドを回避。小さなドキュメント（2KB 未満）が多い場合に検討。 |
| **バージョン** | 4.0 | MongoDB 4.0 互換。一部の機能が制限される可能性がある。 |
|  | 5.0 | MongoDB 5.0 互換。ドキュメント圧縮などの最新機能が利用可能。 |

これらの情報を把握することで、トラブルシューティングの方向性を絞り込み、効率的に問題解決を進めることができます。

## トラブルシュートに必要な情報の収集

トラブルシュートを行うためには調査のための材料を集める必要があります。
はじめに現在の状況を確認し質問の項目に答えるための材料を集めるのに有用な[メトリクス](https://docs.aws.amazon.com/documentdb/latest/developerguide/cloud_watch.html)や 
[MongoDB API](https://docs.aws.amazon.com/documentdb/latest/developerguide/functional-differences.html) 、
[Amazon Command Line Interface (CLI)](https://aws.amazon.com/jp/cli/) のコマンドを説明します。  

### Step 1. メトリクスの確認

[AWS マネジメントコンソール](https://aws.amazon.com/jp/console/)の DocumentDB の画面にはいくつかのメトリクスについてすぐに確認ができるように用意がしてあります。これらのメトリクスを確認することで簡単にトラブルシューティングのポイントを把握することができるため、まずはマネージメントコンソール上のメトリクスを確認することからはじめます。

* 左のナビゲーションペインから**クラスター**を選び、表示された中から対象のクラスターを選択し、**モニタリング**というタブから各ノードのリソース状況の確認を行います。

* 以下の画面ではプライマリノード、レプリカノードに関する CPU 使用率や FreeableMemory といった主だったメトリクスを可視化してくれます。

* その他にもクラスタやデータノード、[Amazon Elastic Block Store](https://aws.amazon.com/jp/ebs/) (EBS) ボリュームなどに関する各種メトリクスについては [Amazon CloudWatch](https://aws.amazon.com/jp/cloudwatch/) から確認できます。本記事ではいくつかのメトリクスについて確認を行いますが、詳細については [Amazon CloudWatch を用いた DocumentDB クラスターメトリクスのモニタリング](https://docs.aws.amazon.com/ja_jp/documentdb/latest/developerguide/cloud_watch.html)を参照してください。

特に、スパイク対応時には以下のメトリクスの監視が重要です：

1. **リソース使用率関連**
   - `SwapUsage`: スワップメモリの使用量。増加は深刻なメモリ不足の兆候
   - `VolumeBytesUsed`: 使用中のストレージ容量。急激な増加はデータ量の異常な増加を示唆
   - `BackupRetentionPeriodStorageUsed`: バックアップストレージの使用量
   - `TotalBackupStorageBilled`: 請求対象のバックアップストレージ

2. **接続関連**
   - `DatabaseConnectionsMax`: 最大同時接続数。スパイク時の接続数上限を把握
   - `DatabaseConnectionsCurrent`: 現在の接続数
   - `DatabaseConnectionsSystemError`: システムエラーによる接続失敗数

3. **パフォーマンス関連**
   - `ReadLatency`/`WriteLatency`: 読み書きの遅延時間。スパイク時の性能低下を検知
   - `ReadThroughput`/`WriteThroughput`: 読み書きのスループット
   - `ReadIOPS`/`WriteIOPS`: 1秒あたりの読み書き操作数
   - `DiskQueueDepth`: ディスクキューの深さ。I/Oの待ち状態を示す

これらのメトリクスには適切なアラートを設定し、閾値を超えた場合に迅速に対応できるようにすることが推奨されます。例えば：

- `SwapUsage` > 50MB: メモリ不足の早期警告
- `DatabaseConnectionsCurrent` が `DatabaseConnectionsMax` の80%超: 接続数の逼迫
- `DiskQueueDepth` > 64: I/O待ちの発生

### Step 2. AWS CLI をつかったクラスタの設定値の取得

下記の AWS CLI のコマンドはクラスターに関する設定情報を取得するためのものです。詳細は[ドキュメント](https://docs.aws.amazon.com/cli/latest/reference/docdb/describe-db-clusters.html)を参照してください。`CLUSTER-NAME` を調べたい対象のクラスター名に変更して実行してください。

```
# DocumentDB のクラスターの設定情報の取得
aws docdb describe-db-clusters --db-cluster-identifier CLUSTER-NAME
```

### Step 3. MongoDB API を使ったノード/インデックスに関する情報の取得

MongoDB API にはさまざまな値を取得するための API が用意されていますが、次のものはそれぞれ基本的なクラスタの情報をはじめ、現在のクラスタ内のノードやインデックスの状況を把握するための API になっています。


```
# ノードのスペック情報取得
db.adminCommand({serverStatus: 1})

# インデックス一覧取得。インデックスのサイズが適切かを確認する。
db.collection.getIndexes()

# インデックス使用状況の確認
db.collection.aggregate([{$indexStats:{}}]).pretty()

# 実行中のクエリの確認
db.adminCommand({currentOp: 1, $all: 1})
```

Amazon DocumentDBでは MongoDB シェルを使用してデータを操作したり、クエリを実行したりすることができます。AWS マネジメントコンソールからクラスターに接続する方法や、mongo シェルを使用する方法については[ドキュメント](https://docs.aws.amazon.com/documentdb/latest/developerguide/getting-started.connect.html)を参照してください。

また次のように、`mongo` コマンドを使ってローカルから API を呼び出すこともできます。下記は認証を使っている場合のコマンド例になります。

```
# mongo シェルでの接続
mongo --ssl --host cluster-endpoint:27017 --sslCAFile global-bundle.pem --username user --password password
```

ここで説明している API によって取得できる各種情報に関してはトラブルシューティングを行う上での基本的な情報になるため、ひとまず全て取得することをおすすめします。

## インデックス

Amazon DocumentDBでは、インデックスの作成にあたって複数の重要な決定が必要です：

- インデックス作成の完了までにどの程度の時間を許容できるか
- インデックス作成中にコレクションへのアクセスを制限できるか
- インスタンスのコンピューティングリソースをどの程度インデックス作成に割り当てられるか
- どのタイプのインデックスを作成すべきか

### インデックスの種類と特徴

Amazon DocumentDBでは以下のタイプのインデックスがサポートされています：

- 単一フィールドインデックス：コレクション内の単一のフィールドに対するインデックス
- 複合インデックス：複数のフィールドを組み合わせた単一のインデックス構造
- マルチキーインデックス：配列フィールドの各要素に対してインデックスキーを作成
- 複合マルチキーインデックス：マルチキーインデックスと非マルチキーインデックスの組み合わせ
- スパースインデックス：一部のドキュメントにのみ存在するフィールドに対するインデックス
- TTL（Time to Live）インデックス：ドキュメントの有効期限を設定するインデックス
- テキストインデックス：テキストフィールド内の単語やフレーズを検索するためのインデックス
- 部分インデックス：指定された条件に一致するドキュメントのみをインデックス化
- ベクトルインデックス：ベクトル検索のためのインデックス

### インデックス作成のベストプラクティス

1. **インデックス作成の計画**
   - 作成時間とリソース使用量を考慮
   - メンテナンス時間帯での実行を検討
   - 必要最小限のインデックスのみを作成

2. **パフォーマンスへの影響**
   - インデックスが多すぎると書き込みパフォーマンスが低下
   - メモリ使用量とストレージコストが増加
   - インデックスの選択性を考慮（重複値が1%未満が理想的）

3. **並列インデックス作成**
   - Amazon DocumentDB 4.0以降でサポート
   - プライマリインスタンスのvCPU数の半分まで並列ワーカーを使用可能
   - 2xlarge以下のインスタンスでは非サポート

4. **インデックスのメンテナンス**
   - 定期的な使用状況の確認
   - 未使用インデックスの削除
   - 必要に応じたreIndexの実行

関連URL：
- [Amazon DocumentDBでのインデックスの使い方](https://aws.amazon.com/blogs/database/how-to-index-on-amazon-documentdb-with-mongodb-compatibility/)
- [部分インデックスを使用したクエリパフォーマンスの向上](https://aws.amazon.com/blogs/database/improve-query-performance-using-partial-indexes-in-amazon-documentdb/)
- [Amazon DocumentDBの並列インデックス作成機能](https://aws.amazon.com/blogs/database/unlock-the-power-of-parallel-indexing-in-amazon-documentdb/)

Amazon DocumentDBでは以下のタイプのインデックスがサポートされています：

- 単一フィールドインデックス：コレクション内の単一のフィールドに対するインデックス
- 複合インデックス：複数のフィールドを組み合わせた単一のインデックス構造
- マルチキーインデックス：配列フィールドの各要素に対してインデックスキーを作成
- 複合マルチキーインデックス：マルチキーインデックスと非マルチキーインデックスの組み合わせ
- スパースインデックス：一部のドキュメントにのみ存在するフィールドに対するインデックス
- TTL（Time to Live）インデックス：ドキュメントの有効期限を設定するインデックス
- テキストインデックス：テキストフィールド内の単語やフレーズを検索するためのインデックス
- 部分インデックス：指定された条件に一致するドキュメントのみをインデックス化
- ベクトルインデックス：ベクトル検索のためのインデックス

関連URL：
- [Amazon DocumentDBでのインデックスの使い方](https://aws.amazon.com/blogs/database/how-to-index-on-amazon-documentdb-with-mongodb-compatibility/)
- [部分インデックスを使用したクエリパフォーマンスの向上](https://aws.amazon.com/blogs/database/improve-query-performance-using-partial-indexes-in-amazon-documentdb/)
- [Amazon DocumentDBの並列インデックス作成機能](https://aws.amazon.com/blogs/database/unlock-the-power-of-parallel-indexing-in-amazon-documentdb/)

Amazon DocumentDBのインデックス作成には以下の基本的な制限と設定のトレードオフがあります：

- Amazon DocumentDB 4.0以降でのみ複数ワーカーによるインデックス作成をサポートしています。
- インデックス作成プロセスでワーカー数を増やすと、プライマリインスタンスのCPU使用率とread IOが増加します。インデックス作成に使用されるリソースは実行中のワークロードでは使用できません。
- Elastic Clustersでは並列インデックス作成はサポートされていません。
- 最大ワーカー数はデータベースクラスターのプライマリインスタンスのvCPU数の半分です。例えば、64 vCPUを持つdb.r6g.16xlargeインスタンスでは最大32ワーカーを実行できます。
- 2xlarge以下のインスタンスクラスでは並列ワーカーはサポートされていません。
- ワーカー数の最小値は1です。インスタンスベースのクラスターでのインデックス作成のデフォルト設定は2ワーカーです。ただし、"worker threads"オプションを使用してワーカー数を1に減らすことができます。
- Amazon DocumentDBはインデックス圧縮をサポートしていません。インデックスのデータサイズは他のオプションを使用する場合よりも大きくなる可能性があります。
- データベースクラスターのプライマリインスタンスのvCPU数の半分を、複数のコレクションでインデックスを作成する設定済みワーカーに使用できます。

インデックスのメンテナンスには`reIndex`コマンドを使用します。これは通常、インデックスが破損したり非効率になった場合に使用されます。更新、挿入、削除が多数行われると、インデックスには未使用の領域が蓄積され、パフォーマンスが低下する可能性があります。reindexingはこのような未使用領域を削除し、インデックスの効率を回復させるのに役立ちます。

`reIndex`の使用にあたっては以下のガイドラインに注意してください：

- Amazon DocumentDB 5.0でのみサポートされています。
- バックグラウンドでの単一インデックスのreindexをサポートし、複数のワーカーを使用できます。reIndex処理の実行中も古いインデックスはクエリで使用可能です。
- `currentOp`を通じてインデックス作成の進捗レポートをサポートしています。インデックス作成時と同様のインデックスビルドステージを確認できます。
- 同じコレクション上のインデックス関連コマンド（createIndexes、dropIndexes、collMod、renameCollection）を除き、任意のコマンドと同時に実行できます。
- テキストインデックス、地理空間インデックス、ベクトルインデックス、部分インデックスについては現在サポートされていません。

## インスタンスサイジングとメモリ最適化

Amazon DocumentDBでインスタンスサイズを選択する際の最も重要な要素の1つは、キャッシュ用のRAM容量です。DocumentDBは自身のサービスのためにRAMの3分の1を予約し、残りの3分の2のみがキャッシュとして利用可能です。そのため、ワーキングセット（データとインデックス）をメモリに収めるのに十分なRAMを持つインスタンスタイプを選択することが重要です。

### BufferCacheHitRatioの監視と最適化

`BufferCacheHitRatio`は、インスタンスのメモリキャッシュから提供されるデータとインデックスの割合を示すCloudWatchメトリクスです。このメトリクスの最適化は以下の点で重要です：

- 値は可能な限り100%に近いことが望ましい
- メモリからの読み取りはストレージボリュームからの読み取りよりも高速で費用対効果が高い
- アプリケーションのアクセスパターンとパフォーマンス要件によって最適な値は異なる

`BufferCacheHitRatio`が低い場合は、以下の対策を検討してください：

1. インスタンスサイズのスケールアップ
   - より多くのRAMを確保してワーキングセットをメモリに収容
   - スケールアップ後に`BufferCacheHitRatio`が大幅に改善する場合は継続的な監視を実施

2. ワークロードの分離
   - 運用クエリとアナリティクスクエリを異なるインスタンスで実行
   - 読み取り負荷を複数のレプリカに分散

3. メモリ使用率の最適化
   - 不要なインデックスの削除
   - 複合インデックスの効果的な使用
   - インデックスフィールドの選択の見直し

### パフォーマンス監視のベストプラクティス

1. **定期的なメトリクス監視**
   - `BufferCacheHitRatio`の変動傾向の分析
   - メモリ使用率とクエリパフォーマンスの相関関係の確認
   - アナリティクスクエリ実行時の影響評価

2. **プロアクティブな容量計画**
   - ワーキングセットサイズの定期的な評価
   - 将来の成長を見据えたインスタンスサイズの選択
   - 季節変動や特別なイベントを考慮した計画立案

3. **パフォーマンス最適化**
   - インデックス使用状況の定期的な確認
   - クエリパターンの分析と最適化
   - 必要に応じたインスタンスタイプの見直し

## トラブルシュートのための質問

ここまでトラブルシュートに関する質問に答えるための情報を集める方法について確認してきました。ここからはその情報を使って実際に問題を特定するための質問に回答していきます。以下の図は本記事でのトラブルシュートに関する質問回答のフローチャートになります。  


### 1. クラスタヘルスや負荷の状況から問題を切り分ける

まずは、メトリクスや問題が起きているクエリの種類からおおまかな問題の切り分けを行います。

1.1. マネージメントコンソールから確認できるクラスタの各ノードのヘルスに異常なものがありますか?

* ヘルスが赤色の場合、クラスターに重大な問題が発生しています。この場合、以下のように原因を確認して対応を行ってください。  
   * `CPUUtilization`、 `FreeableMemory` などのメトリクスを確認して負荷に対するリソースが不足していないか確認してください。  
   * 詳細については[クラスターのトラブルシューティングに関するドキュメント](https://docs.aws.amazon.com/documentdb/latest/developerguide/troubleshooting.html)を確認してください。


1.2. マネージメントコンソールから確認したデータノードのメトリクスから`リソース使用状況`や`クエリのレイテンシー`に偏りはありますか？

* これらのメトリクスに偏りがみられる場合、特定のノードに負荷が偏っていることが伺えます。要因としては、リードレプリカの設定やクエリの分散が適切でない可能性があります。後述の、**2 : インデックスに関する問題を確認する** を確認してください。


1.3. 問題が起きているのは書き込み処理ですか？読み取り処理ですか？

* CPU 使用率が高騰しているなどのリソースのメトリクスに異常がある場合は、どのような処理が基の原因になっているかを特定する必要があります。主に、`DBLoad` メトリクスと Performance Insights を確認することでどちらのリクエストが原因で負荷が上昇しているかを判断します。


### 2. インデックスに関する問題を確認する

メトリクスから負荷の偏りが確認できる場合、インデックスに関する問題が起きていることが疑われます。次に示すようなチェック項目を確認して、実際にインデックスに関する問題が起きているか確認します。  
DocumentDBのインデックスの設定変更の方法の詳細については [Amazon DocumentDB インデックスのベストプラクティス](https://docs.aws.amazon.com/documentdb/latest/developerguide/best_practices.html#best_practices-indexes) を参考にしていただくことをお勧めします。


2.1. `db.collection.aggregate([{$indexStats:{}}]).pretty()` の結果について、インデックスの使用状況に偏りがありますか？

* 偏りがある場合、クエリに対して適切なインデックスが使用されていない可能性があります。[ベストプラクティス](https://docs.aws.amazon.com/documentdb/latest/developerguide/best_practices.html#best_practices-indexes)にしたがってインデックスを設定してください。


2.2. `db.collection.getIndexes()` の結果について、各コレクションのインデックス数が多すぎませんか？

* インデックスが多すぎると書き込みパフォーマンスに影響を与える可能性があります。不要なインデックスを削除することを検討してください。


2.3. 必要のない、または使用していないインデックスが多数ありますか？

* 必要のないインデックスが多数あると書き込みパフォーマンスに影響を与え、ストレージコストも増加します。`db.collection.aggregate([{$indexStats:{}}]).pretty()` を使用して使用されていないインデックスを特定し、削除することを検討してください。

2.4. インデックスのサイズは適切ですか？

* インデックスが大きすぎるとメモリ使用量が増加し、パフォーマンスに影響を与える可能性があります。複合インデックスの使用や、インデックスフィールドの選択を見直すことを検討してください。


2.5. １つのコレクションのインデックス数が多すぎませんか？

* 1つのコレクションに多数のインデックスがあると、書き込みパフォーマンスに大きな影響を与える可能性があります。不要なインデックスを削除し、複合インデックスの使用を検討してください。


2.6. クラスタ全体のインデックス数が非常に多くありませんか？

* 全体のインデックス数自体が非常に多くなっている場合、メモリ使用量が増加し、パフォーマンスに影響を与える可能性があります。不要なインデックスを削除し、インスタンスタイプのスケールアップを検討してください。


### 3. 書き込みに関わる問題を確認する

書き込みにまつわる問題が生じている場合は、Performance Insightsやメトリクスの状況を確認して根本の問題がどこにあるのかを特定します。

3.1. `WriteIOPS` や `WriteThroughput` を確認して、書き込み処理のボトルネックがありませんか？

* これらのメトリクスが高い値を示している場合、書き込み処理がボトルネックになっている可能性があります。
* ボトルネックが発生している場合にはあわせて次のメトリクスを確認してください。`FreeStorageSpace` が少なくなっている、或いは `CPUUtilization` が高くなっている場合はリソースが不足している可能性があります。それぞれについて、クラスターのスケールを検討してください。


3.2. `DiskQueueDepth` を確認して、書き込み待ちが発生していませんか?

* 書き込み待ちが発生している場合には `WriteIOPS` や `WriteThroughput` を確認して、EBS の設定変更による IOPS や Throughput の改善、ノードのスケールを検討してください。

3.3. Performance Insightsで待機イベントを確認して、書き込み処理がブロックされていませんか？

* Performance Insightsの待機イベントから、書き込み処理がブロックされている原因を特定できます。例えば、`IO:BufFileWrite` や `IO:DataFileWrite` が多い場合は、ディスクI/Oがボトルネックになっている可能性があります。


3.4. `WriteLatency` と `WriteIOPS` の間に相関が見られますか？

* `WriteIOPS` に対して `WriteLatency` が顕著に増加しているといったように、これら２つのメトリクスの動きに相関がない場合は、リソースの不足が考えられます。IOPS や CPU、メモリーなどのリソースに関するメトリクスを確認して、ボトルネックを特定してください。


### 4. 読み取りクエリに関わる問題を確認する

書き込み処理の場合と同様に、クエリ処理の場合も読み取りにまつわるメトリクスを確認することで根本の原因としてなにが起きているのかを特定していきます。

4.1. Performance Insightsでトップクエリを確認して、遅いクエリがありませんか？

* Performance Insightsのトップクエリから、実行時間が長いクエリを特定できます。これらのクエリに対して、`explain()` を使用して実行計画を確認し、適切なインデックスを作成することを検討してください。


4.2. `ReadLatency` と `ReadIOPS` の間に相関が見られますか？

* 書き込みの場合と同じように、この ２ つのメトリクスを確認してレイテンシーだけが著しく増加しているような場合には、リソースの不足が懸念されます。２ つのメトリクスの乖離がおきているタイミングのリソースメトリクスを確認してボトルネックを特定します。


### 4.3. クエリパフォーマンスの最適化

クエリパフォーマンスを最適化するために、以下の点を確認してください：

1. **クエリプランの分析**
   - `explain()`コマンドを使用して実行計画を確認
   - インデックスの使用状況を確認
   - コレクションスキャンが発生していないか確認

2. **インデックス戦略の最適化**
   - クエリパターンに基づいて適切なインデックスを作成
   - 複合インデックスの順序を最適化
   - インデックスの選択性を考慮（値の重複が1%未満が目安）

3. **クエリの書き方の改善**
   - 必要なフィールドのみを取得するようにプロジェクションを使用
   - 大量のドキュメントを返すクエリには適切な制限を設定
   - アグリゲーションパイプラインでは`$match`を早い段階で使用

4. **Performance Insightsの活用**
   - スロークエリの特定と分析
   - 待機イベントのパターン分析
   - リソース使用率との相関関係の確認

### 5. リソースのメトリクスを確認する

上述の 2 – 4 の項目の質問から問題が起こっている原因の調査を行いました。その結果をもとに問題が生じているタイミングのリソースのメトリクスを確認することで、問題の原因のボトルネックになっている箇所を特定しスケールの検討の材料にします。

5.1. `CPUUtilization`

* 各ノードの CPU を確認します。使用率が 80 % 以上の状態が続く場合にはスケールを検討してください。


5.2. `FreeableMemory`

* 各ノードの空きメモリ量を確認します。空きメモリが少なくなっている場合にはスケールを検討してください。


5.3. `FreeStorageSpace`

* 各ノードの空き容量です。そもそもストレージが不足している場合には、エラーが発生することがあります。こういった場合には、 メトリクスからクラスタ全体とノード毎のストレージが不足していないかを確認して、不要なデータの削除や適宜スケールを検討してください。

### 5.4. CloudWatchメトリクスを使用したインスタンス使用率の評価

DocumentDBのインスタンス使用率を包括的に評価するには、以下のCloudWatchメトリクスを組み合わせて分析することが重要です：

* **NetworkThroughput** - クライアントとインスタンス間のネットワークスループット
* **StorageNetworkThroughput** - インスタンスとクラスターストレージボリューム間のネットワークスループット

これらのメトリクスを合計することで、インスタンスの総ネットワークスループットを把握できます。この合計値がインスタンスクラスの制限に近づいている場合、パフォーマンスの低下が発生する可能性があります。

より詳細な分析のために、以下のメトリクスも確認することをお勧めします：

* **NetworkReceiveThroughput** - クライアントからインスタンスへのネットワークスループット
* **NetworkTransmitThroughput** - インスタンスからクライアントへのネットワークスループット
* **StorageNetworkReceiveThroughput** - ストレージボリュームからインスタンスへのネットワークスループット
* **StorageNetworkTransmitThroughput** - インスタンスからストレージボリュームへのネットワークスループット

ネットワーク使用率が高い場合は、以下の対策を検討してください：

1. より大きなインスタンスクラスへのスケールアップ
2. 書き込みリクエストをバッチ処理してトランザクション数を削減
3. 読み取り専用ワークロードをリードレプリカに分散
4. 不要なインデックスの削除によるI/O負荷の軽減

### 6. その他確認すべきこと

6.1. クラスタの設定を確認してください。DocumentDB のバージョンは最新のものになっていますか？

* バージョンを更新することでパフォーマンスの向上や新機能の利用が可能になる場合があります。


6.2. クラスタの設定を確認してください。EBS のタイプは gp3 ですか？

* ボリュームタイプが gp2 の場合と比べて gp3 では 1000 GiB 以下のボリュームの場合の IOPS のベースラインが高く設定されている関係で、小規模のデータでもより安定した性能をより低価格で達成できます。
* また、gp2 にはバーストバランスという概念があり、バーストバランスが枯渇してしまった場合に性能低下が見られる可能性がありますが、gp3 の場合にはその懸念がありません。バーストバランスの状況については `BurstBalance` を確認してください。
* 詳しくは[ドキュメント](https://docs.aws.amazon.com/ja%5Fjp/emr/latest/ManagementGuide/emr-plan-storage-compare-volume-types.html)を参照してください。

6.3. インスタンスタイプに t3 インスタンスを利用していませんか？

* t系 インスタンスは CPU クレジットを消費してベースラインを超えたパフォーマンスを発揮するバーストと呼ばれる機能を使用します。しかし、CPU クレジットが枯渇してしまった場合に性能が不安定になってしまいます。
* t3 タイプのインスタンスを使用していてパフォーマンスの問題が発生している場合には、`CPUCreditBalance` を確認してください。CPU クレジットが枯渇している場合はインスタンスタイプの変更を検討してください。
* 本番環境では、安定したパフォーマンスを提供するr5やr6gなどのインスタンスタイプの使用を検討してください。


## 用語

|RDBMS|DocumentDB|
|:--|:--|
|Table, View|Collection|
|Row|Document|
|Index|Index|
|Join|Embedded Document|
|Foreign Key|Reference|
|Partition|Shard|

### DocumentDB/MongoDB 専門用語解説

| 用語 | 説明 |
|------|------|
| **コレクション (Collection)** | RDBMSのテーブルに相当。スキーマレスでさまざまな構造のドキュメントを格納できる。 |
| **ドキュメント (Document)** | RDBMSの行に相当。JSONライクなBSON形式で保存される。各ドキュメントには一意の`_id`フィールドが自動的に付与される。 |
| **フィールド (Field)** | RDBMSの列に相当。キーと値のペアで構成される。 |
| **インデックス (Index)** | クエリのパフォーマンスを向上させるためのデータ構造。単一フィールドまたは複数フィールドに対して作成可能。 |
| **複合インデックス (Compound Index)** | 複数のフィールドに対して作成されるインデックス。フィールドの順序が重要。 |
| **シャード (Shard)** | データを複数のサーバーに分散させる方法。Elastic Clusterで使用される。 |
| **レプリカセット (Replica Set)** | 同じデータのコピーを保持する複数のノードのグループ。高可用性を提供。 |
| **プライマリノード (Primary Node)** | 書き込み操作を処理するレプリカセット内の主要ノード。 |
| **セカンダリノード (Secondary Node)** | プライマリノードからデータをレプリケートするノード。読み取り操作に使用可能。 |
| **BSON** | Binary JSON。MongoDB/DocumentDBがデータを保存するためのバイナリ形式。 |
| **アグリゲーションパイプライン (Aggregation Pipeline)** | データ処理のためのフレームワーク。複数のステージを通じてドキュメントを変換・集計する。 |
| **TTL (Time To Live) インデックス** | 指定した時間が経過したドキュメントを自動的に削除するインデックス。 |
| **ワーキングセット (Working Set)** | アクティブに使用されるデータとインデックスのセット。メモリに収まることが理想的。 |
| **バッファキャッシュ (Buffer Cache)** | メモリ内のデータとインデックスのキャッシュ。`BufferCacheHitRatio`で効率を測定。 |
| **WiredTiger** | DocumentDBの基盤となるストレージエンジン。 |
| **オプロガー (Oplog)** | レプリケーションに使用される操作ログ。 |

## API リファレンス

Amazon DocumentDBでサポートされるAPI、オペレーション、データ型の詳細については、以下の公式ドキュメントを参照してください：

* [Amazon DocumentDB でサポートされる MongoDB API、オペレーション、データ型](https://docs.aws.amazon.com/ja_jp/documentdb/latest/developerguide/mongo-apis.html)

## Amazon DocumentDB Elastic Cluster

Amazon DocumentDB Elastic Clusterは、大規模なワークロードに対応するための革新的なソリューションです。[Amazon DocumentDB Elastic Cluster](https://docs.aws.amazon.com/ja_jp/documentdb/latest/developerguide/elastic-how-it-works.html)は、従来のインスタンスベースのクラスターの制限を超えて、より柔軟なスケーリングとパフォーマンス最適化を実現します。

### アーキテクチャと動作原理

Elastic Clusterは、ハッシュベースのシャーディングを採用し、分散ストレージシステム間でデータを効率的に分割します。このアプローチにより、大規模なデータセットを複数のノードに分散させ、従来の垂直スケーリングの限界を超えたスケーラビリティを実現します。特筆すべき点として、コンピューティングとストレージが完全に分離されており、それぞれを独立してスケーリングできる柔軟性を提供します。

シャーディングの実装においては、以下の重要な要素が組み合わさっています：

- 最大32個のシャードをサポートし、各シャードは1つのライターと最大15個のリードレプリカを持つことができます
- 各シャードインスタンスは最大64 vCPUsまでスケール可能で、処理能力を柔軟に調整できます
- データは6つのコピーで構成され、複数のアベイラビリティーゾーンに自動的にレプリケートされ、高い耐久性と可用性を確保します

### パフォーマンス最適化とスケーリング

Elastic Clusterのパフォーマンス最適化は、主に以下の3つの側面から実現されます：

1. データ分散の最適化
   シャードキーを使用して、データを複数のシャードに均等に分散させます。効果的なシャードキーの選択は、全体的なパフォーマンスに大きく影響します。シャードキーには、多数の一意の値を持つフィールドを選択し、データの均等な分散を実現することが重要です。

2. 動的なスケーリング
   ワークロードの変化に応じて、シャードの数（水平スケーリング）とvCPUの数（垂直スケーリング）を柔軟に調整できます。スケーリング操作中もデータの可用性は維持され、アプリケーションへの影響を最小限に抑えることができます。

3. 自動化されたデータ再分散
   新しいシャードが追加された場合、システムは自動的にデータを再分散させ、全シャードにわたって均等な負荷分散を維持します。この処理は効率的に行われ、パフォーマンスへの影響を最小限に抑えます。

### 高可用性と信頼性の確保

Elastic Clusterは、以下の機能により高い可用性と信頼性を実現します：

- 各シャードは異なるアベイラビリティーゾーンに最低2つのノードを配置し、障害に対する耐性を確保
- 自動フェイルオーバーメカニズムにより、ノード障害時の迅速な復旧を実現
- データの6つのコピーを複数のアベイラビリティーゾーンに分散させ、データ損失のリスクを最小化

### Elastic Clusterが特に効果を発揮する状況

Elastic Clusterは、以下のような特定のユースケースで特に効果を発揮します：

1. 大規模データセットの管理
   テラバイト規模のデータを扱う必要がある場合や、将来的な大幅なデータ増加が予想される場合、Elastic Clusterのスケーラビリティは大きな価値を提供します。単一インスタンスの容量限界に近づいているシステムにとって、理想的なソリューションとなります。

2. 高スループットワークロード
   大量の同時接続や高い読み書き負荷を処理する必要がある場合、Elastic Clusterの分散アーキテクチャが効果を発揮します。特に、バースト的なトラフィック増加に対して柔軟に対応できる能力は、多くのユースケースで重要な利点となります。

3. 複雑なワークロードパターン
   地理的に分散したユーザーベースを持つアプリケーションや、バッチ処理と実時間処理が混在するワークロードでは、Elastic Clusterの柔軟なスケーリング能力が有効です。シャーディング可能なデータモデルを持つアプリケーションにとって、特に適しています。

4. コスト最適化の要件
   従来の垂直スケーリングと比較して、水平スケーリングがより費用対効果が高い場合、Elastic Clusterは理想的な選択となります。コンピューティングとストレージを独立してスケールできる特性により、リソースの無駄を最小限に抑えることができます。

### 実装時の重要な考慮事項

Elastic Clusterを実装する際は、以下の点に特に注意を払う必要があります：

1. シャードキー設計
   - データの均等な分散を実現する一意性の高いキーの選択
   - アプリケーションのアクセスパターンとの整合性
   - 将来的なデータ成長を考慮した設計

2. スケーリング戦略
   - 段階的なスケールアウトの計画
   - メトリクスに基づく適切なスケーリングタイミングの決定
   - 各シャードの負荷バランスの継続的な監視

3. パフォーマンスモニタリング
   - シャードごとの詳細なメトリクス監視
   - データ分散の均一性の定期的な確認
   - クエリパフォーマンスの継続的な評価と最適化

これらの考慮事項を適切に管理することで、Elastic Clusterの利点を最大限に活用し、スケーラブルで高性能なデータベース環境を実現することができます。

## バッチ処理と突発的な負荷への対応

多くのシステムでは、通常の運用に加えて、バッチ処理や定期的なデータ分析など、突発的に高い負荷がかかる処理が発生します。これらの処理は、適切に管理されないとDocumentDBのパフォーマンスに大きな影響を与える可能性があります。ここでは、バッチ処理や突発的な負荷に効果的に対応するための戦略について説明します。

### バッチ処理による負荷スパイクの特性と影響

バッチ処理は通常、以下のような特性を持ちます：

1. 短時間に大量のリソースを消費する
   バッチ処理は一般的に、短時間で大量のデータを処理するため、CPU、メモリ、I/O操作などのリソースを急激に消費します。これにより、BufferCacheHitRatioの急激な低下、CPUUtilizationの急上昇、DiskQueueDepthの増加などが発生する可能性があります。

2. 予測可能なパターンで発生することが多い
   多くの場合、バッチ処理は特定の時間帯（深夜や週末など）に定期的に実行されるため、その影響を予測し、事前に対策を講じることが可能です。

3. 通常のオペレーションとは異なるアクセスパターンを持つ
   バッチ処理は、通常のトランザクション処理とは異なり、大量のデータを順次処理したり、複雑な集計を行ったりするため、データベースへのアクセスパターンが大きく異なります。

### バッチ処理と突発的な負荷に対する効果的な対策

1. **時間帯の最適化**

   バッチ処理は、システムの利用が少ない時間帯に実行するようにスケジュールすることが重要です。例えば、ユーザーアクティビティが低下する深夜や早朝、週末などを選択することで、通常のオペレーションへの影響を最小限に抑えることができます。また、複数のバッチ処理が同時に実行されないように、実行時間をずらすことも効果的です。

2. **専用インスタンスの活用**

   重要なバッチ処理や分析クエリは、専用のレプリカインスタンスで実行することを検討すべきです。読み取り専用のレプリカを追加し、そのレプリカにバッチ処理のトラフィックを向けることで、プライマリインスタンスやその他のレプリカへの影響を軽減できます。特に重要なバッチ処理の場合は、処理中だけ一時的にレプリカを追加することも検討に値します。

3. **段階的な処理の実装**

   大規模なバッチ処理は、小さな単位に分割して段階的に実行することで、システム全体への影響を分散させることができます。例えば、1回の処理で100万件のレコードを更新する代わりに、10万件ずつ10回に分けて処理し、各処理の間に適切な休止期間を設けることで、リソースの急激な消費を防ぐことができます。

   ```javascript
   // 段階的な処理の例
   const batchSize = 10000;
   const totalRecords = 1000000;
   const pauseTime = 5000; // 5秒の休止

   for (let i = 0; i < totalRecords; i += batchSize) {
     // batchSize分のレコードを処理
     await processRecords(i, Math.min(i + batchSize, totalRecords));
     
     // システムに休息を与える
     await new Promise(resolve => setTimeout(resolve, pauseTime));
     
     // 必要に応じてメトリクスを確認
     const metrics = await checkSystemMetrics();
     if (metrics.cpuUtilization > 80 || metrics.freeableMemory < threshold) {
       // より長い休止期間を設ける
       await new Promise(resolve => setTimeout(resolve, pauseTime * 3));
     }
   }
   ```

4. **動的なスロットリングの実装**

   バッチ処理の実行中にシステムメトリクスをリアルタイムで監視し、負荷が一定のしきい値を超えた場合に処理速度を自動的に調整するメカニズムを実装することが効果的です。例えば、CPUUtilizationが80%を超えた場合や、BufferCacheHitRatioが急激に低下した場合に、処理速度を落としたり、一時的に処理を停止したりするロジックを組み込むことができます。

5. **インデックス戦略の最適化**

   バッチ処理に特化したインデックス戦略を検討することも重要です。バッチ処理で頻繁にアクセスされるフィールドに適切なインデックスを作成することで、処理効率を大幅に向上させることができます。ただし、インデックスの追加はデータ書き込み時のオーバーヘッドを増加させるため、バッチ処理のパフォーマンス向上と通常のオペレーションへの影響のバランスを慎重に評価する必要があります。

6. **クライアント側のバックオフ戦略**

   バッチ処理を実行するクライアントアプリケーションには、適切なバックオフ戦略を実装することが重要です。エラーやタイムアウトが発生した場合に、指数関数的にバックオフ時間を増やしながらリトライする仕組みを導入することで、システムの回復を促進し、さらなる負荷の集中を防ぐことができます。

   ```javascript
   // エクスポネンシャルバックオフの実装例
   async function executeWithBackoff(operation, maxRetries = 5) {
     let retries = 0;
     
     while (true) {
       try {
         return await operation();
       } catch (error) {
         if (retries >= maxRetries || !isRetryableError(error)) {
           throw error;
         }
         
         const backoffTime = Math.pow(2, retries) * 1000 + Math.random() * 1000;
         console.log(`Retrying after ${backoffTime}ms (attempt ${retries + 1}/${maxRetries})`);
         
         await new Promise(resolve => setTimeout(resolve, backoffTime));
         retries++;
       }
     }
   }
   ```

7. **事前のキャパシティプランニング**

   定期的なバッチ処理や予測可能な負荷スパイクに対しては、事前にキャパシティプランニングを行うことが効果的です。例えば、月末の決算処理や年末の集計処理など、大規模な処理が予定されている場合は、一時的にインスタンスをスケールアップしたり、レプリカを追加したりすることを検討すべきです。AWS Auto Scalingを活用して、スケジュールに基づいた自動スケーリングを設定することも可能です。

8. **Elastic Clusterの活用**

   特に大規模なバッチ処理や頻繁に発生する負荷スパイクがある場合は、前述のElastic Clusterの使用を検討すべきです。Elastic Clusterでは、シャード間でデータが分散されるため、バッチ処理の負荷も分散され、システム全体のパフォーマンスへの影響を軽減できます。また、必要に応じてシャードを追加することで、処理能力を柔軟に拡張することが可能です。

### モニタリングとアラート設定

バッチ処理や突発的な負荷に効果的に対応するためには、適切なモニタリングとアラート設定が不可欠です：

1. **詳細なメトリクス監視**
   
   バッチ処理の実行前、実行中、実行後のシステムメトリクスを詳細に監視し、パターンや傾向を分析することが重要です。特に以下のメトリクスに注目すべきです：
   
   - CPUUtilization：急激な上昇はリソース不足の兆候
   - BufferCacheHitRatio：急激な低下はメモリ不足の兆候
   - DiskQueueDepth：増加はI/Oボトルネックの兆候
   - DatabaseConnections：急増は接続プールの問題を示唆

2. **カスタムダッシュボードの作成**
   
   バッチ処理に特化したカスタムCloudWatchダッシュボードを作成し、関連するメトリクスをまとめて可視化することで、問題の早期発見と迅速な対応が可能になります。

3. **予防的アラートの設定**
   
   バッチ処理の開始前に、システムの状態が最適でない場合（例：CPUUtilizationが既に高い、FreeableMemoryが少ないなど）に警告するアラートを設定することで、潜在的な問題を事前に検出し、対策を講じることができます。

バッチ処理や突発的な負荷に対する戦略を適切に実装することで、DocumentDBのパフォーマンスを維持しながら、必要なデータ処理タスクを効率的に実行することが可能になります。特に、Elastic Clusterの活用、専用インスタンスの使用、段階的な処理の実装、クライアント側のバックオフ戦略などを組み合わせることで、システム全体の安定性と効率性を大幅に向上させることができます。

## Amazon DocumentDB ユーザー診断とパフォーマンス分析

Amazon DocumentDBでは、クラスターのパフォーマンスと使用状況を詳細に分析し、問題を特定するための包括的な診断機能を提供しています。この機能を活用することで、パフォーマンスの問題をより効果的に特定し、解決することができます。詳細は[Amazon DocumentDB ユーザー診断](https://docs.aws.amazon.com/ja_jp/documentdb/latest/developerguide/user_diagnostics.html)を参照してください。

### クエリパフォーマンスの分析

Amazon DocumentDBでは、クエリパフォーマンスを詳細に分析するための多様な診断ツールが提供されています。長時間実行されているクエリを特定するには、`db.adminCommand({currentOp: 1, $all: 1, secs_running: {$gt: 10}})`コマンドを使用します。このコマンドは10秒以上実行されているすべてのクエリを表示し、問題のあるクエリを迅速に特定することができます。特定したクエリは必要に応じて`killOp`コマンドで終了させることも可能です。

クエリの実行効率を分析するためには、`explain()`コマンドが非常に有用です。例えば、`db.collection.find({x: 1}).explain()`を実行すると、クエリプランの詳細が表示され、インデックスの使用状況や実行ステージごとの効率を確認できます。クエリプランの出力には、クエリがインデックスを使用しているか（IXSCAN）、あるいはコレクション全体をスキャンしているか（COLLSCAN）などの重要な情報が含まれています。

システム全体の状態を把握するためには、`db.adminCommand({currentOp: 1, $all: 1})`コマンドを使用して、現在実行中のすべての操作を監視できます。この情報は、リソースの使用状況や潜在的なボトルネックを特定するのに役立ちます。特に複数のクエリが同時に実行される環境では、この情報が非常に重要になります。

### システムパフォーマンスの診断

キャッシュパフォーマンスはDocumentDBのシステム全体のパフォーマンスに大きく影響します。`db.collection.stats()`コマンドを実行すると、出力の`cacheStats`セクションでキャッシュの効率性に関する重要な指標を確認できます。`collBlksHit`（キャッシュからの読み取り数）と`collBlksRead`（ディスクからの読み取り数）の比率である`collHitRatio`は、キャッシュの効率を示す重要な指標です。この比率が低い場合、メモリ容量の増加やインデックス戦略の見直しが必要かもしれません。

CPU使用率の高騰は様々な要因によって引き起こされます。長時間実行されているクエリの存在、リソースの競合状況、同時実行クエリの数の増加、非効率的なインデックス使用などが主な原因として考えられます。これらの問題を特定するためには、CloudWatchメトリクスとPerformance Insightsを組み合わせて分析することが効果的です。特に、`CPUUtilization`メトリクスが80%を超える状態が継続する場合は、根本的な原因を特定し、適切な対策を講じる必要があります。

インデックスの使用状況を詳細に分析するには、`db.collection.aggregate([{$indexStats:{}}]).pretty()`コマンドが非常に有効です。このコマンドの出力から、各インデックスの使用頻度、読み取りドキュメント数、キャッシュヒット率などの情報を得ることができます。これらの情報を基に、使用されていないインデックスを特定して削除したり、頻繁に使用されるクエリに対して最適なインデックスを作成したりすることができます。

### パフォーマンス問題の診断と解決

システムの速度低下は、多くの場合、複数の要因が組み合わさって発生します。同時クエリ間のリソース競合、アクティブな同時クエリ数の増加、ガベージコレクションなどの内部システムタスクが主な原因として挙げられます。これらの問題を特定するためには、時間の経過とともにシステムの使用状況を継続的にモニタリングすることが重要です。

リソース競合の状況を詳細に分析するには、以下のようなコマンドが有効です：

```javascript
db.adminCommand({
    aggregate: 1,
    pipeline: [{$currentOp: {}}, {$match: {$or: [{secs_running: {$gt: 10}}, {WaitState: {$exists: true}}]}}],
    cursor: {}
})
```

このコマンドは、10秒以上実行されているか、リソースを待機しているすべてのクエリを表示します。出力に`WaitState`フィールドがある場合、そのクエリはリソースの競合によってブロックされていることを示しています。さらに、`blockedOn`フィールドを確認することで、どのクエリや操作がブロックの原因となっているかを特定できます。

インデックスの最適化はパフォーマンス向上の鍵となります。未使用のインデックスを定期的に特定して削除することで、書き込みパフォーマンスの向上とストレージコストの削減が可能です。同時に、頻繁に実行されるクエリに対して適切なインデックスを作成することで、読み取りパフォーマンスを大幅に向上させることができます。インデックスのサイズと数のバランスを取ることが重要であり、特に書き込みが多いワークロードでは、インデックス数を最小限に抑えることが推奨されます。

### パフォーマンス改善のためのアプローチ

読み取り負荷の分散は、システム全体のパフォーマンスを向上させる効果的な方法です。セカンダリノードを活用して読み取りクエリを分散させることで、プライマリノードの負荷を軽減し、全体的なスループットを向上させることができます。クライアントの読み込み優先設定（`secondaryPreferred`など）を使用することで、レプリカ間で読み込みトラフィックを効果的に分散させることが可能です。また、ElastiCacheなどのサービスを併用することで、頻繁にアクセスされるデータのキャッシュ層を追加し、データベースへの負荷をさらに軽減することができます。

リソースの適切なサイジングは、コスト効率とパフォーマンスのバランスを取るために不可欠です。ワークロードの特性に応じて適切なインスタンスタイプを選択することが重要です。メモリ集約型のワークロードでは、ワーキングセット（データとインデックス）がメモリに収まるように十分なRAMを持つインスタンスを選択すべきです。ストレージ設定も重要な要素であり、I/Oコストが全体の25%以上を占める場合は、I/O最適化ストレージの使用を検討する価値があります。

定期的なモニタリングとメンテナンスは、長期的なパフォーマンスを維持するために不可欠です。CloudWatchアラームを設定して主要メトリクスを継続的に監視し、潜在的な問題を早期に検出することが重要です。Performance Insightsを活用してクエリパフォーマンスを追跡し、問題のあるクエリを特定して最適化することも効果的です。また、定期的にインデックス使用状況を確認し、不要なデータやインデックスを削除することで、システムのパフォーマンスと効率性を維持することができます。

## パフォーマンス最適化のためのベストプラクティス

DocumentDBのパフォーマンスを最適化するためには、サーバー側とクライアント側の両方の観点から包括的なアプローチが必要です。[Amazon DocumentDBのベストプラクティス](https://docs.aws.amazon.com/ja_jp/documentdb/latest/developerguide/best_practices.html#best_practices-performance)に基づき、効率的な運用のための重要な考慮事項を説明します。

### インスタンスサイジングとメモリ管理

Amazon DocumentDBでインスタンスサイズを選択する際の最も重要な要素は、キャッシュ用のRAM容量です。DocumentDBは自身のサービスのためにRAMの3分の1を予約し、残りの3分の2のみがキャッシュとして利用可能となります。そのため、ワーキングセット（データとインデックス）をメモリに収めるのに十分なRAMを持つインスタンスタイプを選択することが重要です。本番環境では、安定したパフォーマンスを提供するR5/R6gなどのメモリ最適化インスタンスの使用が推奨されます。

BufferCacheHitRatioは、インスタンスのメモリキャッシュから提供されるデータとインデックスの割合を示す重要なメトリクスです。この値は可能な限り100%に近づけることが理想的です。メモリからの読み取りはストレージボリュームからの読み取りよりも高速で費用対効果が高いためです。BufferCacheHitRatioが低下している場合は、インスタンスサイズのスケールアップを検討すべきです。また、FreeableMemoryがインスタンスメモリの10%を下回る場合も、同様にスケールアップが必要となる可能性があります。

ストレージ構成も最適化の重要な側面です。I/Oコストが全体の25%以上を占める場合は、I/O-Optimized Storageの使用を検討すべきです。また、gp3ボリュームタイプを採用することで、より予測可能なパフォーマンスを確保できます。将来の成長を見据えた容量計画を立案し、定期的に見直すことも重要です。

### クライアント側の重要な最適化戦略

アプリケーションの回復性とパフォーマンスを向上させるためには、クライアント側の実装も非常に重要です。特にエラーハンドリングとリトライ戦略は慎重に設計する必要があります。一時的なエラーと永続的なエラーを適切に区別し、一時的なエラーに対してはエクスポネンシャルバックオフを実装することが推奨されます。例えば、最初は短い待機時間でリトライし、その後徐々に待機時間を増やしていくアプローチです。このようなリトライ戦略を実装する際には、データの整合性を常に考慮することが重要です。

接続管理も最適化すべき重要な領域です。コネクションプールを適切に設定し、最大接続数を監視して必要に応じて制限を設けることで、リソースの効率的な利用が可能になります。また、アイドル接続のタイムアウトを適切に設定することで、不要なリソース消費を防ぐことができます。

ネットワークの耐性向上も見逃せない要素です。適切なタイムアウト値を設定し、レプリカセットモードでの接続による高可用性を確保することが重要です。さらに、クラスターエンドポイントを使用することで、フェイルオーバー時のアプリケーションへの影響を最小限に抑えることができます。

### インデックス戦略の最適化

インデックスは慎重に設計・管理する必要があります。効率的なインデックス設計のためには、クエリパターンに基づいて適切なインデックスを作成することが重要です。複合インデックスを使用する場合は、選択性の高いフィールドを先頭に配置することでパフォーマンスが向上します。また、ベストプラクティスとして、コレクションあたりのインデックス数は5以下に抑えることが推奨されています。

インデックスの継続的な監視と最適化も欠かせません。`db.collection.aggregate([{$indexStats:{}}])`コマンドを使用して、インデックスの使用状況を定期的に確認し、未使用のインデックスを特定して削除することが重要です。また、インデックスの選択性を評価し、重複値が1%未満となるフィールドにインデックスを作成することが理想的です。

### クエリパフォーマンスの最適化

クエリの効率を最大化するためには、まずクエリパターンの詳細な分析が必要です。Performance Insightsを活用してスロークエリを特定し、`explain()`コマンドを使用してクエリプランを詳細に分析することで、最適化の余地を見つけることができます。大規模な結果セットを返すクエリには適切な制限を設定し、システムリソースの過剰消費を防ぐことも重要です。

アグリゲーションパイプラインを使用する場合は、早期の段階で`$match`ステージを配置し、処理するドキュメント数を減らすことでパフォーマンスを向上させることができます。また、必要最小限のフィールドのみを取得するようにプロジェクションを設定し、複雑な計算はできるだけアプリケーション側で実行することも検討すべきです。

### 包括的な監視とメンテナンス

システムの健全性を維持するためには、包括的な監視体制が不可欠です。CloudWatchアラームを設定して主要メトリクスを継続的に監視し、潜在的な問題を早期に検出することが重要です。特にCPUUtilization（80%以上が継続する場合は要注意）、FreeableMemory（10%を下回る場合は要注意）、BufferCacheHitRatio（可能な限り100%に近づける）、WriteIOPS/ReadIOPS（急激な変動がないか監視）などのメトリクスに注目すべきです。

定期的なメンテナンスと最適化も長期的なパフォーマンスを維持するために重要です。パフォーマンスメトリクスを定期的に評価し、インデックス使用状況を見直すことで、システムの効率性を維持できます。また、不要なデータを特定してアーカイブし、最新バージョンへの更新を検討することも重要です。

キャパシティプランニングは、将来のニーズに備えるために欠かせません。成長予測に基づいて事前にスケーリング計画を立て、季節変動やイベントの影響を考慮することで、突発的な負荷増加にも対応できるようになります。コストとパフォーマンスのバランスを最適化することも、効率的な運用のために重要な要素です。

## [CPU使用率のトラブルシューティング](https://repost.aws/ja/knowledge-center/documentdb-troubleshoot-high-cpu)

Amazon DocumentDB クラスターで CPU 使用率が高くなる主な原因として、インデックスが適切に設定されていない、または使用されていないことが挙げられます。インデックスが存在しない場合、クエリの実行時にコレクション全体をスキャンする必要があり、CPU 使用率が上昇します。また、既存のインデックスが使用されていない場合も同様の問題が発生します。

大量のデータを処理するクエリの実行も CPU 使用率の上昇につながります。大規模なデータセットに対する集計操作、複雑な結合操作を含むクエリ、大量のドキュメントを返すクエリなどが該当します。同時実行されるクエリの数が多い場合、多数のクライアントからの同時接続やバッチ処理、レポート生成などの重い処理の同時実行により、CPU 使用率が高くなることがあります。

インスタンスタイプが不適切な場合も CPU 使用率の上昇を引き起こします。ワークロードに対してインスタンスのキャパシティが不足している場合や、バースト可能なインスタンスタイプ（T3など）でのCPUクレジットの枯渇が発生した場合に問題が生じます。

これらの問題に対する解決策として、まずインデックスの最適化が重要です。クエリパターンを分析し、適切なインデックスを作成することで、クエリのパフォーマンスを向上させることができます。使用されていないインデックスを特定して削除し、複合インデックスを効果的に活用することも有効です。

クエリの最適化も重要な対策となります。クエリプランを分析して改善を行い、必要なフィールドのみを取得するようにプロジェクションを使用します。大量のデータを返すクエリにはページネーションを実装することで、CPU 負荷を分散させることができます。

接続管理の改善も効果的です。コネクションプールを適切に設定し、長時間実行されるクエリを監視・制御します。読み取り負荷をレプリカに分散させることで、プライマリインスタンスの CPU 負荷を軽減できます。

インスタンス設定の最適化も検討すべき重要な要素です。ワークロードに適したインスタンスタイプを選択し、必要に応じてスケールアップまたはスケールアウトを行います。メモリ使用率を監視し、最適化することで、CPU 使用率の改善にもつながります。

モニタリングとトラブルシューティングには、Performance Insights を活用することが推奨されます。トップクエリの特定と分析、待機イベントのパターン分析、リソース使用率の傾向把握が可能です。CloudWatch メトリクスでは、CPUUtilization、DatabaseConnections、FreeableMemory、ReadIOPS/WriteIOPS などの重要な指標を監視します。

予防的な対策として、キャパシティプランニングが重要です。ワークロードの成長予測、季節変動の考慮、適切なバッファの確保を行います。自動スケーリングの設定も有効で、CloudWatch アラームの設定、スケーリングポリシーの定義、テスト環境での検証を行います。

定期的なメンテナンスとして、インデックスの使用状況の確認、不要なデータのアーカイブ、パフォーマンスメトリクスの定期的な評価を実施します。プロアクティブなモニタリングにより、問題を早期に検出し、対応することが可能です。

効率的なクエリ設計では、インデックスを考慮したクエリ作成、バッチ処理の最適化、適切なページネーションの実装を心がけます。リソース管理においては、適切なインスタンスタイプの選択、リソース使用率の定期的な見直し、コストとパフォーマンスのバランス最適化を行います。

## Performance Insights

gt

## 最後に

本記事では、DocumentDB のトラブルについて、質問形式で根本の問題を特定するためのチェックポイントをまとめました。上記の確認項目に加えて、理想的にはアプリケーション側のログやメトリクスと付き合わせることで問題特定の精度を高めることも検討してください。また、DocumentDB へのデータ投入に [mongoimport](https://docs.mongodb.com/database-tools/mongoimport/) や [mongorestore](https://docs.mongodb.com/database-tools/mongorestore/) といったツールを使用している場合にはそちらがボトルネックになっていないか確認していただくことも重要です。  
DocumentDB を構築する際にはインスタンスタイプやインデックスの設定などについてパフォーマンスやコスト最適といった観点での[ベストプラクティス](https://docs.aws.amazon.com/documentdb/latest/developerguide/best_practices.html)が紹介されています。最初に構築する際にはこちらを参考にしていただき、そもそも問題が起きにくいような構成を検討していただくことも重要になります。  
実際にトラブルが起きてしまった際には、本記事の質問への回答を実施して問題の特定のための参考にしていただければ幸いです。

## References

- [Awsome MongoDB](https://github.com/ramnes/awesome-mongodb)
