# Amazon DocumentDB スパイク対策 - インデックス問題ソリューション

## インデックス作成ガイドライン

Amazon DocumentDB でインデックスを作成する際は、以下のガイドラインを考慮することが重要です：

* **Amazon DocumentDB バージョンのサポート**: 単一ワーカーインデックス作成はすべての Amazon DocumentDB バージョンでサポートされていますが、マルチワーカーインデックスは Amazon DocumentDB バージョン 4.0 と 5.0 でのみサポートされています。
* **パフォーマンスのトレードオフ**: インデックス作成プロセスのワーカー数を増やすと、Amazon DocumentDB データベースのプライマリインスタンスの CPU 使用率と読み取り I/O が増加します。新しいインデックスを作成するのに必要なリソースは、実行中のワークロードでは使用できなくなります。
* **Elastic クラスター**: Amazon DocumentDB Elastic クラスターでは並列インデックスはサポートされていません。
* **最大ワーカー**: 設定できるワーカーの最大数は、データベースクラスター内のプライマリインスタンスのサイズによって異なります。これは、データベースクラスターのプライマリインスタンスにある vCPU の総数の半分です。たとえば、64 個の vCPU を備えた db.r6g.16xlarge インスタンスでは、最大 32 ワーカーを実行できます。
  * 並列ワーカーは 2xlarge 以下のインスタンスクラスではサポートされていません。
* **最小ワーカー**: 設定できるワーカーの最小数は 1 です。インスタンスベースのクラスターでのインデックス作成のデフォルト設定は 2 ワーカーです。ただし、「ワーカースレッド」オプションを使用すると、ワーカーの数を 1 つに減らすことができます。
* **インデックス圧縮**: Amazon DocumentDB はインデックス圧縮をサポートしていません。インデックスのデータサイズは、他のオプションを使用したときより大きくなる可能性があります。

### インデックス作成コマンド

特定のコレクションでインデックスの作成を開始するには、`createIndexes` コマンドを使用します：

```javascript
// デフォルト（2ワーカー）でインデックスを作成
db.runCommand({"createIndexes":"test","indexes":[{"key": {"user_name":1}, "name":"username_idx"}]})

// 4つの並列ワーカーを使用してインデックス作成を高速化
db.runCommand({"createIndexes":"test","indexes":[{"key": {"user_name":1}, "name":"username_idx", "workers":4}]})
```

ワーカーの数が増えるほど、インデックスの作成が速くなりますが、プライマリインスタンスの vCPU と読み取り IO のロードも大きくなります。他のワークロードを低下させることなく、増加したロードを処理できるよう、クラスターが十分にプロビジョニングされていることを確認してください。

## インデックスビルドタイプ

Amazon DocumentDB では、以下の4つのインデックスビルドタイプがサポートされています：

1. **フォアグラウンド**: フォアグラウンドインデックスビルドは、インデックスが作成されるまで、他のすべてのデータベース操作をブロックします。5つのステージで構成されています。
2. **フォアグラウンド (単一)**: 単一ドキュメント (単一) フォアグラウンドインデックスビルドは、通常のフォアグラウンドビルドのような他のデータベース操作をブロックします。基本的なフォアグラウンドビルドとは異なり、単一ビルドでは追加のステージ (ソートキー 2) を使用して重複キーを探します。6つのステージで構成されます。
3. **バックグラウンド**: バックグラウンドでのインデックス構築により、インデックスの作成中に他のデータベース操作をフォアグラウンドで実行できます。8つのステージで構成されています。
4. **バックグラウンド (単一)**: 単一ドキュメント (単一) のバックグラウンドインデックス構築により、インデックスの作成中に他のデータベース操作をフォアグラウンドで実行できます。基本的なバックグラウンドビルドとは異なり、単一ビルドでは追加のステージ (ソートキー 2) を使用して重複キーを探します。9つのステージで構成されます。

## インデックスビルドステージ

インデックス作成プロセスは、初期化、コレクションのスキャン、キーのソート、そして最後にインデックスビルダーによるキーの挿入によって行われます。このプロセスは、フォアグラウンドで実行する場合は最大6段階、バックグラウンドで実行する場合は最大9段階に分かれます。

| ステージ | フォアグラウンド | フォアグラウンド (単一) | バックグラウンド | バックグラウンド (単一) |
| --- | --- | --- | --- | --- |
| 初期化 | 1 | 1 | 1 | 1 |
| インデックスの構築: 初期化 | 2 | 2 | 2 | 2 |
| インデックスの構築: コレクションのスキャン | 3 | 3 | 3 | 3 |
| インデックスの構築: ソートキー 1 | 4 | 4 | 4 | 4 |
| インデックスの構築: ソートキー 2 |  | 5 |  | 5 |
| インデックスの構築: キーの挿入 | 5 | 6 | 5 | 6 |
| 検証: インデックスのスキャン |  |  | 6 | 7 |
| 検証: タプルのソート |  |  | 7 | 8 |
| 検証: コレクションのスキャン |  |  | 8 | 9 |

各ステージの説明：

* **初期化**: createIndex はインデックスビルダーを準備しています。このフェーズは非常に短いはずです。
* **インデックスの構築: 初期化**: インデックスビルダーはインデックスを作成する準備をしています。このフェーズは非常に短いはずです。
* **インデックスの構築: コレクションのスキャン**: インデックスビルダーはコレクションスキャンを実行してインデックスキーを収集しています。測定単位は「ブロック」です。
  * インデックス構築用に複数のワーカーが設定されている場合は、この段階で表示されます。「コレクションのスキャン」ステージは、インデックス構築プロセス中に複数のワーカーを使用する唯一のステージです。
* **インデックスの構築: ソートキー 1**: インデックスビルダーは収集されたインデックスキーをソートしています。測定単位は「キー」です。
* **インデックスの構築: ソートキー 2**: インデックスビルダーは、収集されたデッドタプルに対応するインデックスキーをソートします。このフェーズは単一インデックスの構築にのみ適用されます。測定単位は「キー」です。
* **インデックスの構築: キーの挿入**: インデックスビルダーは、新しいインデックスにインデックスキーを挿入しています。測定単位は「キー」です。
* **検証: インデックスのスキャン**: createIndex はインデックスをスキャンして、検証が必要なキーを見つけます。測定単位は「ブロック」です。
* **検証: タプルのソート**: createIndex はインデックススキャンフェーズの出力をソートしています。
* **検証: コレクションのスキャン**: createIndex はコレクションをスキャンして、前の 2 つのフェーズで見つかったインデックスキーを検証しています。測定単位は「ブロック」です。

### インデックスビルドの進捗モニタリング

mongo シェルの `db.currentOp()` コマンドを使用して、インデックス作成プロセスの進行状況をモニタリングできます：

```javascript
db.currentOp({"command.createIndexes": { $exists : true } })
```

出力例：
```javascript
{
    "inprog" : [{
        "command": {
            "createIndexes": "test",
            "indexes": [{
                "v": 2,
                "key": {
                    "user_name": 1
                },
                "name": "user_name_1"
            }],
            "lsid": {
                "id": UUID("094d0fba-8f41-4373-82c3-7c4c7b5ff13b")
            },
            "$db": "test"
        },
        "currentIndexBuildName": user_name_1,
        "msg": "Index Build: building index number_1, stage 6/6 building index: 656860/1003520 (keys) 65%",
        "workers": 1,
        "progress": {
            "done": 656861,
            "total": 1003520
        },
    }],
    "ok" : 1
}
```

「msg」フィールドには、ビルドのステージと完了率を示すことで、ビルドの進捗状況がまとめられています。「workers」フィールドは、インデックスビルドの各段階で使用されたワーカーの数を示します。「progress」フィールドには、完了率の計算に使用された実際の数値が表示されます。

注意: インデックス作成の進行状況の表示は、Amazon DocumentDB 5.0 でのみサポートされています。

## インデックスメンテナンス

### reIndex を使用したインデックスの再構築

`reIndex` は、インデックスの再構築に使用されるコマンドです。通常、インデックスが破損したり、または非効率的になった場合に使用されます。時間の経過とともに、インデックスには多くの更新、挿入、削除に伴い未使用のスペースが蓄積され、パフォーマンスが低下する恐れがあります。インデックスの再構築は、このような未使用のスペースを削除し、インデックスの効率を回復するのに役立ちます。

#### reIndex のガイドライン

* `reIndex` は現在、Amazon DocumentDB 5.0 でのみサポートされています。
* Amazon DocumentDB は、バックグラウンドでの 1 つのインデックスに対する `reindex` をサポートし、複数のワーカーの関与を可能にします。`reIndex` プロセスの実行中も、古いインデックスを用いたクエリの実行が可能です。
* Amazon DocumentDB は、`currentOp` によるインデックス構築の進行状況レポートをサポートしています。
* `reIndex` は、同じコレクション上で実行されるインデックス関連のコマンド (`createIndexes`、`dropIndexes`、`collMod`、`renameCollection`) を除いて、あらゆるコマンドと同時に実行できます。
* `reIndex` は現在、テキスト、地理空間、ベクトル、部分インデックスについてはサポートされていません。

#### reIndex の使用方法

次のコマンドを使用してインデックスを再構築します：

```javascript
db.runCommand({ reIndex: "collection-name", index: "index-name"})
```

オプションで、再構築プロセスに割り当てるワーカーの数をコントロールすることもできます：

```javascript
db.runCommand({ reIndex: "collection-name", index: "index-name", workers: number })
```

#### reIndex の使用タイミング

以下のような状況で `reIndex` の使用を検討してください：

* インデックスのパフォーマンスが時間とともに低下している場合
* 大量の更新/削除操作の後にインデックスの効率を回復させたい場合
* インデックスの断片化が疑われる場合
* クエリのパフォーマンスが予期せず低下した場合

reIndex 操作は、特に大規模なコレクションでは時間がかかる可能性があるため、メンテナンスウィンドウ中や負荷の少ない時間帯に実行することをお勧めします。

## 5.1 未使用インデックス削除

使用されていないインデックスを特定して削除します。`db.collection.aggregate([{$indexStats:{}}])`を使用して使用状況を確認し、不要なインデックスを削除します。未使用のインデックスは、メモリを消費し、書き込みパフォーマンスに影響を与える可能性があるため、定期的な見直しが重要です。

## 5.2 必要なインデックス追加

クエリパターンに基づいて必要なインデックスを追加します。新規インデックスの作成は、クエリのパフォーマンスを大幅に向上させる可能性がありますが、書き込みオーバーヘッドも考慮する必要があります。クエリパターンの分析に基づいて、最適なインデックス戦略を決定します。

## 5.3 複合インデックスフィールド順序最適化

複合インデックスのフィールド順序を最適化します。インデックスの再作成時にフィールド順序を変更することで、クエリのパフォーマンスを向上させることができます。フィールドの選択性や使用頻度を考慮して、最適な順序を決定します。

## 5.4 より選択性の高いフィールドでインデックス作成

選択性の高いフィールド（重複値が1%未満）を優先してインデックスを作成します。インデックス設計の見直しにより、クエリの効率を向上させることができます。フィールドの選択性は、インデックスの効果を決定する重要な要因です。

## 5.5 部分インデックス検討またはインデックス圧縮

部分インデックスの使用を検討します。条件付きインデックスの作成により、インデックスのサイズを削減し、メモリ使用量を最適化できます。特定の条件に基づいてインデックスを作成することで、必要なデータのみをインデックス化できます。

## 5.6 その他のインデックス最適化戦略検討

インデックスの種類や設定を見直し、インデックス戦略を総合的に最適化します。これには以下のような戦略が含まれます：

- インデックスの定期的な再構築
- インデックスキーの最適なデータ型の選択
- インデックスの使用状況の継続的なモニタリング
- バックグラウンドインデックス作成の活用
- インデックス作成のタイミング最適化
