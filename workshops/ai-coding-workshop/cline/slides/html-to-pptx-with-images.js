const pptxgen = require('pptxgenjs');
const fs = require('fs');
const path = require('path');
const cheerio = require('cheerio');
const imageSize = require('image-size');

/**
 * HTML を PowerPoint スライドに変換する（画像サポート付き）
 */
async function convertHtmlToSlides() {
    // HTML ファイルを読み込む
    const htmlFile = path.join(__dirname, 'preview-with-images.html');
    const htmlContent = fs.readFileSync(htmlFile, 'utf-8');
    
    // HTML を解析
    const $ = cheerio.load(htmlContent);
    
    // PowerPoint プレゼンテーションを作成
    const pres = new pptxgen();
    
    // プレゼンテーションの基本設定
    pres.layout = 'LAYOUT_WIDE';
    pres.author = 'Generated by PptxGenJS';
    pres.company = 'AI Coding Workshop';
    pres.revision = '1';
    pres.subject = 'HTML to PowerPoint with Images';
    
    // カラーテーマの設定
    const THEME = {
        background: 'F5F5F5',
        primary: '007BFF',
        secondary: '6C757D',
        accent: '28A745',
        text: '333333'
    };
    
    // スライドマスターの設定
    pres.defineSlideMaster({
        title: 'MASTER_SLIDE',
        background: { color: THEME.background },
        margin: [0.5, 1.0, 0.5, 1.0],
        objects: [
            { 'rect': { 
                options: { 
                    x: 0, 
                    y: 6.8, 
                    w: '100%', 
                    h: 0.1, 
                    fill: { color: THEME.secondary }
                }
            }},
            { 'text': { 
                options: {
                    text: '${slideNumber}/${totalSlides}',
                    x: '90%',
                    y: 6.9,
                    w: '8%',
                    fontSize: 10,
                    color: THEME.secondary,
                    align: 'right'
                }
            }}
        ]
    });
    
    // タイトルスライドの作成
    const titleSlide = pres.addSlide({ masterName: 'MASTER_SLIDE' });
    titleSlide.addText($('h1').first().text(), {
        x: '10%',
        y: '40%',
        w: '80%',
        h: '20%',
        fontFace: 'Arial',
        fontSize: 44,
        color: THEME.primary,
        bold: true,
        align: 'center',
        valign: 'middle'
    });
    
    // 見出しごとにスライドを作成
    $('h2').each((i, h2) => {
        const $h2 = $(h2);
        const slideTitle = $h2.text();
        let slide = pres.addSlide({ masterName: 'MASTER_SLIDE' });
        
        // スライドタイトルを設定
        slide.addText(slideTitle, {
            x: '10%',
            y: 0.5,
            w: '80%',
            h: 1.5,
            fontFace: 'Arial',
            fontSize: 28,
            color: THEME.primary,
            bold: true,
            align: 'center'
        });
        
        // 見出しの次の要素を取得
        let $content = $h2.next();
        let contentY = 2.0;
        
        // 次の見出しまでの要素を処理
        while ($content.length && !$content.is('h2')) {
            if ($content.is('table')) {
                // テーブルの処理
                try {
                    const tableData = [];
                    
                    // ヘッダー行の処理
                    const headerCells = [];
                    $content.find('thead tr th').each((j, th) => {
                        headerCells.push($(th).text().trim());
                    });
                    
                    if (headerCells.length > 0) {
                        tableData.push(headerCells);
                    }
                    
                    // データ行の処理
                    $content.find('tbody tr').each((j, tr) => {
                        const rowCells = [];
                        $(tr).find('td').each((k, td) => {
                            rowCells.push($(td).text().trim());
                        });
                        if (rowCells.length > 0) {
                            tableData.push(rowCells);
                        }
                    });
                    
                    // テーブルをスライドに追加（データがある場合のみ）
                    if (tableData.length > 0) {
                        // テーブルデータをコンソールに出力（デバッグ用）
                        console.log('テーブルデータ:', JSON.stringify(tableData));
                        
                        // テーブルをスライドに追加（中央揃え）
                        slide.addTable(tableData, {
                            x: '10%',
                            y: contentY,
                            w: '80%',
                            color: THEME.text,
                            fontSize: 18,
                            border: { type: 'solid', pt: 1, color: THEME.secondary },
                            align: 'center',
                            valign: 'middle'
                        });
                    }
                    contentY += 3.0;
                } catch (error) {
                    console.error('テーブルの処理でエラーが発生しました:', error);
                }
            } else if ($content.is('img') || $content.find('img').length > 0) {
                // 画像の処理（直接のimg要素またはp要素内のimg要素）
                const $img = $content.is('img') ? $content : $content.find('img');
                const imgSrc = $img.attr('src');
                
                if (imgSrc) {
                    try {
                        // Base64画像の処理
                        if (imgSrc.startsWith('data:image')) {
                            // Base64文字列からMIMEタイプとデータを抽出
                            const matches = imgSrc.match(/^data:image\/([a-zA-Z]+);base64,(.+)$/);
                            if (matches) {
                                const imageType = matches[1];
                                const base64Data = matches[2];
                                
                                // 画像のタイプに応じて処理を分ける
                                if ($img.attr('data-type') === 'mermaid') {
                                    // Mermaid図の場合
                                    slide.addImage({
                                        data: imgSrc,
                                        x: '10%',
                                        y: contentY,
                                        w: '80%',
                                        align: 'center',
                                    });
                                    contentY += 3.0; // Mermaid図の後は大きめの余白
                                } else {
                                    // 通常の画像の場合
                                    slide.addImage({
                                        data: imgSrc,
                                        x: '10%',
                                        y: contentY,
                                        w: '80%',
                                        h: 4.0,  // 固定高さ
                                        align: 'center',
                                        sizing: {
                                            type: 'contain',
                                            w: '80%',
                                            h: '50%'  // スライドの高さの50%
                                        }
                                    });
                                    contentY += 4.5; // 画像の高さ + 余白
                                }
                                console.log(`Base64画像を処理しました (type: ${imageType})`);
                            }
                        }
                    } catch (error) {
                        console.error('画像の処理でエラーが発生しました:', error);
                        console.error('画像のソース:', imgSrc.substring(0, 100) + '...');
                    }
                }
            } else if ($content.is('p')) {
                // 段落の処理
                const segments = [];
                let currentText = '';

                // 段落内の要素を処理
                $content.contents().each((k, node) => {
                    if (node.type === 'text') {
                        currentText += $(node).text();
                    } else if (node.name === 'a') {
                        // 現在のテキストがあれば追加
                        if (currentText) {
                            segments.push({ text: currentText.trim() });
                            currentText = '';
                        }
                        // リンクを追加
                        segments.push({
                            text: $(node).text(),
                            options: {
                                hyperlink: { url: $(node).attr('href') },
                                color: '0000FF',
                                underline: true
                            }
                        });
                    } else if (node.name === 'strong' || node.name === 'b') {
                        currentText += $(node).text();
                    } else if (node.name === 'em' || node.name === 'i') {
                        currentText += $(node).text();
                    } else if (node.name === 'code') {
                        currentText += $(node).text();
                    }
                });

                // 残りのテキストがあれば追加
                if (currentText) {
                    segments.push({ text: currentText.trim() });
                }

                // 段落をスライドに追加
                slide.addText(segments, {
                    x: '10%',
                    y: contentY,
                    w: '80%',
                    h: 0.8,
                    fontSize: 24,
                    color: THEME.text,
                    align: 'left'
                });
                contentY += 1.0;
            } else if ($content.is('pre')) {
                // コードブロックの処理
                const codeText = $content.text();
                
                // コメント行（#で始まる行）を検出して色分けするための処理
                const codeLines = codeText.split('\n');
                const textSegments = [];
                
                codeLines.forEach((line, index) => {
                    // 行の先頭に # がある場合はコメント行として処理
                    if (line.trim().startsWith('#')) {
                        textSegments.push({
                            text: line + (index < codeLines.length - 1 ? '\n' : ''),
                            options: { color: '00FF00' } // 緑色でコメントを表示
                        });
                    } else {
                        textSegments.push({
                            text: line + (index < codeLines.length - 1 ? '\n' : ''),
                            options: { color: 'FFFFFF' } // 通常のコードは白色
                        });
                    }
                });
                
                slide.addText(textSegments, {
                    x: '10%',
                    y: contentY,
                    w: '80%',
                    h: 1.2 * (codeLines.length || 1), // 行数に応じて高さを調整
                    fontSize: 16,  // フォントサイズを小さく
                    fontFace: 'Courier New',
                    align: 'left',
                    fill: { color: '262626' }, // VSCodeのダークテーマに近い背景色
                    lineSpacing: 16, // 行間隔をフォントサイズと同じに設定
                    valign: 'top', // 垂直方向の配置を上部に
                    margin: [5, 5, 5, 5], // 上下左右のマージンを追加
                    padding: [10, 10, 10, 10] // パディングを増やして余白を確保
                });
                contentY += 1.0 * (codeText.split('\n').length || 1) + 0.5; // コードブロックの後に余白を追加
            } else if ($content.is('ul, ol')) {
                // リストの処理
                const listItems = [];
                const isOrderedList = $content.is('ol');
                
                // リスト項目を処理
                $content.find('> li').each((j, li) => {
                    const $li = $(li);
                    const prefix = isOrderedList ? `${j + 1}.` : '';
                    
                    // リスト項目のHTMLを解析してリンク情報を保持
                    const segments = [];
                    let currentText = '';

                    // リスト項目のテキストから記号を完全に削除
                    const cleanText = (text) => {
                        return text
                            .replace(/^[・•\s]+|[・•\s]+$/g, '') // 前後の記号を削除
                            .replace(/[・•]/g, '')              // 文中の記号を削除
                            .trim();
                    };

                    $li.contents().each((k, node) => {
                        if (node.type === 'text') {
                            // 前後の空白を除去してテキストを追加
                            const text = cleanText($(node).text());
                            if (text) {
                                currentText += text;
                            }
                        } else if (node.name === 'a') {
                            // 現在のテキストがあれば追加
                            if (currentText) {
                                segments.push({ text: currentText.trim() });
                                currentText = '';
                            }
                            // リンクを追加
                            segments.push({
                                text: cleanText($(node).text()),
                                options: {
                                    hyperlink: { url: $(node).attr('href') },
                                    color: '0000FF',
                                    underline: true
                                }
                            });
                        } else if (node.name === 'strong' || node.name === 'b') {
                            currentText += cleanText($(node).text());
                        } else if (node.name === 'em' || node.name === 'i') {
                            currentText += cleanText($(node).text());
                        } else if (node.name === 'code') {
                            currentText += cleanText($(node).text());
                        }
                    });

                    // 残りのテキストがあれば追加
                    if (currentText) {
                        segments.push({ text: currentText.trim() });
                    }

                    // プレフィックスを追加
                    segments.unshift({ text: `${prefix} ` });
                    
                    listItems.push(segments);
                    
                    // ネストされたリストがある場合は、インデントを追加して処理
                    $li.find('> ul, > ol').each((k, nestedList) => {
                        const $nestedList = $(nestedList);
                        const isNestedOrdered = $nestedList.is('ol');
                        
                        $nestedList.find('> li').each((l, nestedLi) => {
                            const $nestedLi = $(nestedLi);
                            const nestedPrefix = isNestedOrdered ? `${l + 1}.` : '';
                            
                            // 親リストと同様の段階的な処理を行う
                            const nestedSegments = [];
                            let nestedCurrentText = '';
                            
                            // プレフィックスを追加（インデントはレイアウトオプションで制御）
                            nestedSegments.push({ text: nestedPrefix + ' ' });
                            
                            $nestedLi.contents().each((m, node) => {
                                if (node.type === 'text') {
                                    const text = cleanText($(node).text());
                                    if (text) {
                                        nestedCurrentText += text;
                                    }
                                } else if (node.name === 'a') {
                                    if (nestedCurrentText) {
                                        nestedSegments.push({ text: nestedCurrentText.trim() });
                                        nestedCurrentText = '';
                                    }
                                    nestedSegments.push({
                                        text: cleanText($(node).text()),
                                        options: {
                                            hyperlink: { url: $(node).attr('href') },
                                            color: '0000FF',
                                            underline: true
                                        }
                                    });
                                } else if (node.name === 'strong' || node.name === 'b') {
                                    nestedCurrentText += cleanText($(node).text());
                                } else if (node.name === 'em' || node.name === 'i') {
                                    nestedCurrentText += cleanText($(node).text());
                                } else if (node.name === 'code') {
                                    nestedCurrentText += cleanText($(node).text());
                                }
                            });
                            
                            // 残りのテキストがあれば追加
                            if (nestedCurrentText) {
                                nestedSegments.push({ text: nestedCurrentText.trim() });
                            }
                            
                            listItems.push(nestedSegments);
                        });
                    });
                });

                // リストを複数のテキストブロックに分割（自動改ページ対応）
                const MAX_ITEMS_PER_BLOCK = 5; // 1ブロックあたりの最大項目数
                
                for (let i = 0; i < listItems.length; i += MAX_ITEMS_PER_BLOCK) {
                    const blockItems = listItems.slice(i, i + MAX_ITEMS_PER_BLOCK);
                    const blockHeight = 0.8 * blockItems.length; // リストの項目数に応じて高さを調整
                    
                    // スライドの高さをチェック
                    if (contentY + blockHeight > 5.5) {
                        // 新しいスライドを作成
                        slide = pres.addSlide({ masterName: 'MASTER_SLIDE' });
                        slide.addText(slideTitle + ' (続き)', {
                            x: '10%',
                            y: 0.5,
                            w: '80%',
                            h: 1.5,
                            fontFace: 'Arial',
                            fontSize: 28,
                            color: THEME.primary,
                            bold: true,
                            align: 'center'
                        });
                        contentY = 2.0;
                    }
                    
                    // リストブロックをスライドに追加
                    blockItems.forEach((segments, idx) => {
                        const options = {
                            x: segments[0].text.startsWith('•') || segments[0].text.match(/^\d+\./) ? '12%' : '16%', // ネストレベルに応じてインデントを調整
                            y: contentY + (idx * 0.8),
                            w: '78%',
                            h: 0.8,
                            fontSize: 24,
                            color: THEME.text,
                            align: 'left',
                            bullet: { type: false } // PowerPointの自動箇条書きは使用しない
                        };

                        if (Array.isArray(segments)) {
                            // セグメントの配列の場合（リンクを含む場合）
                            slide.addText(segments.map(seg => {
                                if (typeof seg === 'string') {
                                    return { text: seg };
                                }
                                return seg;
                            }), options);
                        } else {
                            // 通常のテキストの場合（ネストされたリストなど）
                            slide.addText(segments, options);
                        }
                    });
                    
                    contentY += blockHeight + 0.2; // リストの後に少し余白を追加
                }
            }
            
            // 次の要素に移動（長いコンテンツの自動改ページ）
            $content = $content.next();
            
            // スライドの高さをチェック
            if (contentY > 5.5) {
                // 新しいスライドを作成
                slide = pres.addSlide({ masterName: 'MASTER_SLIDE' });
                slide.addText(slideTitle + ' (続き)', {
                    x: '10%',
                    y: 0.5,
                    w: '80%',
                    h: 1.5,
                    fontFace: 'Arial',
                    fontSize: 28,
                    color: THEME.primary,
                    bold: true,
                    align: 'center'
                });
                contentY = 2.0;
            }
        }
    });
    
    // プレゼンテーションを保存
    const outputPath = path.join(__dirname, 'html-output-with-images.pptx');
    await pres.writeFile({ fileName: outputPath });
    console.log(`スライドを生成しました: ${outputPath}`);
}

convertHtmlToSlides().catch(console.error);
